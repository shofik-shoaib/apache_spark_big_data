<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Scala Reflection Library 2.13.12 - scala.reflect.api</title><meta content="Scala Reflection Library 2.13.12 - scala.reflect.api" name="description"/><meta content="Scala Reflection Library 2.13.12 scala.reflect.api" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript" src="https://d3js.org/d3.v4.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title">Scala Reflection Library<span id="doc-version">2.13.12</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.scala" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scala" class="anchorToMember"></a><a id="scala:scala" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">scala</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="scala.reflect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="reflect" class="anchorToMember"></a><a id="reflect:reflect" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">reflect</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="scala" id="scala" class="extype">scala</a></dd></dl></div></li><li class="indented3 current" name="scala.reflect.api" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="api" class="anchorToMember"></a><a id="api:api" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">api</span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>The Scala Reflection API (located in scala-reflect.jar).</p><p>In Scala 2.10.0, the Scala Reflection API and its implementation have an "experimental" status.
This means that the API and the docs are not complete and can be changed in binary- and source-incompatible
manner in 2.10.1. This also means that the implementation has some known issues.</p><p>The following types are the backbone of the Scala Reflection API, and serve as a good starting point
for information about Scala Reflection:</p><ul><li><a href="Symbols.html" name="scala.reflect.api.Symbols" id="scala.reflect.api.Symbols" class="extype">scala.reflect.api.Symbols</a></li><li><a href="Types.html" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a></li><li><a href="Mirrors.html" name="scala.reflect.api.Mirrors" id="scala.reflect.api.Mirrors" class="extype">scala.reflect.api.Mirrors</a></li><li><a href="Universe.html" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a></li></ul><p> For more information about Scala Reflection, see the
<a href="https://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="scala.reflect" id="scala.reflect" class="extype">reflect</a></dd></dl></div></li><li class="current-entities indented3"><span class="separator"></span> <a href="Annotations.html" title="EXPERIMENTAL" class="trait"></a><a href="Annotations.html" title="EXPERIMENTAL">Annotations</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Constants.html" title="EXPERIMENTAL" class="trait"></a><a href="Constants.html" title="EXPERIMENTAL">Constants</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Exprs.html" title="EXPERIMENTAL" class="trait"></a><a href="Exprs.html" title="EXPERIMENTAL">Exprs</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="FlagSets.html" title="EXPERIMENTAL" class="trait"></a><a href="FlagSets.html" title="EXPERIMENTAL">FlagSets</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ImplicitTags.html" title="Tags which preserve the identity of abstract types in the face of erasure." class="trait"></a><a href="ImplicitTags.html" title="Tags which preserve the identity of abstract types in the face of erasure.">ImplicitTags</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Internals.html" title="EXPERIMENTAL" class="trait"></a><a href="Internals.html" title="EXPERIMENTAL">Internals</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="JavaUniverse.html" title="EXPERIMENTAL" class="trait"></a><a href="JavaUniverse.html" title="EXPERIMENTAL">JavaUniverse</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Liftables.html" title="" class="trait"></a><a href="Liftables.html" title="">Liftables</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Mirror.html" title="EXPERIMENTAL" class="class"></a><a href="Mirror.html" title="EXPERIMENTAL">Mirror</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Mirrors.html" title="EXPERIMENTAL" class="trait"></a><a href="Mirrors.html" title="EXPERIMENTAL">Mirrors</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Names.html" title="EXPERIMENTAL" class="trait"></a><a href="Names.html" title="EXPERIMENTAL">Names</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Position.html" title="EXPERIMENTAL" class="trait"></a><a href="Position.html" title="EXPERIMENTAL">Position</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Positions.html" title="EXPERIMENTAL" class="trait"></a><a href="Positions.html" title="EXPERIMENTAL">Positions</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Printers.html" title="EXPERIMENTAL" class="trait"></a><a href="Printers.html" title="EXPERIMENTAL">Printers</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Quasiquotes.html" title="" class="trait"></a><a href="Quasiquotes.html" title="">Quasiquotes</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Scopes.html" title="EXPERIMENTAL" class="trait"></a><a href="Scopes.html" title="EXPERIMENTAL">Scopes</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="StandardDefinitions.html" title="EXPERIMENTAL" class="trait"></a><a href="StandardDefinitions.html" title="EXPERIMENTAL">StandardDefinitions</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="StandardLiftables.html" title="" class="trait"></a><a href="StandardLiftables.html" title="">StandardLiftables</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="StandardNames.html" title="EXPERIMENTAL" class="trait"></a><a href="StandardNames.html" title="EXPERIMENTAL">StandardNames</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Symbols.html" title="EXPERIMENTAL" class="trait"></a><a href="Symbols.html" title="EXPERIMENTAL">Symbols</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="TreeCreator.html" title="A mirror-aware factory for trees." class="class"></a><a href="TreeCreator.html" title="A mirror-aware factory for trees.">TreeCreator</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Trees.html" title="EXPERIMENTAL" class="trait"></a><a href="Trees.html" title="EXPERIMENTAL">Trees</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="TypeCreator.html" title="A mirror-aware factory for types." class="class"></a><a href="TypeCreator.html" title="A mirror-aware factory for types.">TypeCreator</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="TypeTags.html" title="A TypeTag[T] encapsulates the runtime type representation of some type T." class="trait"></a><a href="TypeTags.html" title="A TypeTag[T] encapsulates the runtime type representation of some type T.">TypeTags</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Types.html" title="EXPERIMENTAL" class="trait"></a><a href="Types.html" title="EXPERIMENTAL">Types</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Universe.html" title="EXPERIMENTAL" class="class"></a><a href="Universe.html" title="EXPERIMENTAL">Universe</a></li><li class="indented3 " name="scala.reflect.macros" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="macros" class="anchorToMember"></a><a id="macros:macros" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/macros/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../macros/index.html" title="EXPERIMENTAL"><span class="name">macros</span></a></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> The base package for Scala macros.</p><p> Macros are functions that are called by the compiler during compilation.
 Within these functions the programmer has access to compiler APIs.
 For example, it is possible to generate, analyze and typecheck code.</p><p> See the <a href="https://docs.scala-lang.org/overviews/macros/overview.html" target="_blank">Macros Guide</a> on how to get started with Scala macros.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="scala.reflect" id="scala.reflect" class="extype">reflect</a></dd></dl></div></li><li class="indented3 " name="scala.reflect.runtime" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runtime" class="anchorToMember"></a><a id="runtime:runtime" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/runtime/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../runtime/index.html" title="Entry points into runtime reflection."><span class="name">runtime</span></a></span><p class="shortcomment cmt">Entry points into runtime reflection.</p><div class="fullcomment"><div class="comment cmt"><p>Entry points into runtime reflection.
 See <a href="" name="scala.reflect.api" id="scala.reflect.api" class="extype">the overview page</a> for details on how to use them.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="scala.reflect" id="scala.reflect" class="extype">reflect</a></dd></dl></div></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../../index.html" name="scala" id="scala" class="extype">scala</a>.<a href="../index.html" name="scala.reflect" id="scala.reflect" class="extype">reflect</a></p><h1>api<span class="permalink"><a href="../../../scala/reflect/api/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">api</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>The Scala Reflection API (located in scala-reflect.jar).</p><p>In Scala 2.10.0, the Scala Reflection API and its implementation have an "experimental" status.
This means that the API and the docs are not complete and can be changed in binary- and source-incompatible
manner in 2.10.1. This also means that the implementation has some known issues.</p><p>The following types are the backbone of the Scala Reflection API, and serve as a good starting point
for information about Scala Reflection:</p><ul><li><a href="Symbols.html" name="scala.reflect.api.Symbols" id="scala.reflect.api.Symbols" class="extype">scala.reflect.api.Symbols</a></li><li><a href="Types.html" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a></li><li><a href="Mirrors.html" name="scala.reflect.api.Mirrors" id="scala.reflect.api.Mirrors" class="extype">scala.reflect.api.Mirrors</a></li><li><a href="Universe.html" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a></li></ul><p> For more information about Scala Reflection, see the
<a href="https://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a>
</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/scala/scala/tree/v2.13.12src/reflect/scala/reflect/api/package.scala#L52" target="_blank">package.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div><div id="content-diagram-container" class="toggleContainer block diagram-container"><span class="toggle diagram-link">Content Hierarchy</span><div id="content-diagram" class="diagram hiddenContent"><svg id="graph1" class="package-diagram" width="800" height="600"></svg><script type="text/dot" id="dot1">
digraph G {
  
  
  node0 [URL="TypeTags.html#inheritance-diagram-container", label="TypeTags", id="graph1_0", class="default", tooltip="scala.reflect.api.TypeTags"] ;
  node1 [URL="Mirrors.html#inheritance-diagram-container", label="Mirrors", id="graph1_1", class="default", tooltip="scala.reflect.api.Mirrors"] ;
  node2 [URL="StandardNames.html#inheritance-diagram-container", label="StandardNames", id="graph1_2", class="default", tooltip="scala.reflect.api.StandardNames"] ;
  node3 [URL="Universe.html#inheritance-diagram-container", label="Universe", id="graph1_3", class="default", tooltip="scala.reflect.api.Universe"] ;
  node4 [URL="Scopes.html#inheritance-diagram-container", label="Scopes", id="graph1_4", class="default", tooltip="scala.reflect.api.Scopes"] ;
  node5 [URL="ImplicitTags.html#inheritance-diagram-container", label="ImplicitTags", id="graph1_5", class="default", tooltip="scala.reflect.api.ImplicitTags"] ;
  node6 [URL="Types.html#inheritance-diagram-container", label="Types", id="graph1_6", class="default", tooltip="scala.reflect.api.Types"] ;
  node7 [URL="Positions.html#inheritance-diagram-container", label="Positions", id="graph1_7", class="default", tooltip="scala.reflect.api.Positions"] ;
  node8 [URL="Internals.html#inheritance-diagram-container", label="Internals", id="graph1_8", class="default", tooltip="scala.reflect.api.Internals"] ;
  node9 [URL="Names.html#inheritance-diagram-container", label="Names", id="graph1_9", class="default", tooltip="scala.reflect.api.Names"] ;
  node10 [URL="Trees.html#inheritance-diagram-container", label="Trees", id="graph1_10", class="default", tooltip="scala.reflect.api.Trees"] ;
  node11 [URL="StandardLiftables.html#inheritance-diagram-container", label="StandardLiftables", id="graph1_11", class="default", tooltip="scala.reflect.api.StandardLiftables"] ;
  node12 [URL="Quasiquotes.html#inheritance-diagram-container", label="Quasiquotes", id="graph1_12", class="default", tooltip="scala.reflect.api.Quasiquotes"] ;
  node13 [URL="Annotations.html#inheritance-diagram-container", label="Annotations", id="graph1_13", class="default", tooltip="scala.reflect.api.Annotations"] ;
  node14 [URL="Exprs.html#inheritance-diagram-container", label="Exprs", id="graph1_14", class="default", tooltip="scala.reflect.api.Exprs"] ;
  node15 [URL="Constants.html#inheritance-diagram-container", label="Constants", id="graph1_15", class="default", tooltip="scala.reflect.api.Constants"] ;
  node16 [URL="Symbols.html#inheritance-diagram-container", label="Symbols", id="graph1_16", class="default", tooltip="scala.reflect.api.Symbols"] ;
  node17 [URL="FlagSets.html#inheritance-diagram-container", label="FlagSets", id="graph1_17", class="default", tooltip="scala.reflect.api.FlagSets"] ;
  node18 [URL="JavaUniverse.html#inheritance-diagram-container", label="JavaUniverse", id="graph1_18", class="default", tooltip="scala.reflect.api.JavaUniverse"] ;
  node19 [URL="StandardDefinitions.html#inheritance-diagram-container", label="StandardDefinitions", id="graph1_19", class="default", tooltip="scala.reflect.api.StandardDefinitions"] ;
  node20 [URL="Printers.html#inheritance-diagram-container", label="Printers", id="graph1_20", class="default", tooltip="scala.reflect.api.Printers"] ;
  node21 [URL="Liftables.html#inheritance-diagram-container", label="Liftables", id="graph1_21", class="default", tooltip="scala.reflect.api.Liftables"] ;
  
  
  node3 -> node18 [arrowtail="empty", dir="back", id="graph1_3_18", class="inheritance", tooltip="JavaUniverse is a subtype of Universe"] ;
  node16 -> node3 [arrowtail="empty", dir="back", id="graph1_16_3", class="inheritance", tooltip="Universe is a subtype of Symbols"] ;node6 -> node3 [arrowtail="empty", dir="back", id="graph1_6_3", class="inheritance", tooltip="Universe is a subtype of Types"] ;node17 -> node3 [arrowtail="empty", dir="back", id="graph1_17_3", class="inheritance", tooltip="Universe is a subtype of FlagSets"] ;node4 -> node3 [arrowtail="empty", dir="back", id="graph1_4_3", class="inheritance", tooltip="Universe is a subtype of Scopes"] ;node9 -> node3 [arrowtail="empty", dir="back", id="graph1_9_3", class="inheritance", tooltip="Universe is a subtype of Names"] ;node10 -> node3 [arrowtail="empty", dir="back", id="graph1_10_3", class="inheritance", tooltip="Universe is a subtype of Trees"] ;node15 -> node3 [arrowtail="empty", dir="back", id="graph1_15_3", class="inheritance", tooltip="Universe is a subtype of Constants"] ;node13 -> node3 [arrowtail="empty", dir="back", id="graph1_13_3", class="inheritance", tooltip="Universe is a subtype of Annotations"] ;node7 -> node3 [arrowtail="empty", dir="back", id="graph1_7_3", class="inheritance", tooltip="Universe is a subtype of Positions"] ;node14 -> node3 [arrowtail="empty", dir="back", id="graph1_14_3", class="inheritance", tooltip="Universe is a subtype of Exprs"] ;node0 -> node3 [arrowtail="empty", dir="back", id="graph1_0_3", class="inheritance", tooltip="Universe is a subtype of TypeTags"] ;node5 -> node3 [arrowtail="empty", dir="back", id="graph1_5_3", class="inheritance", tooltip="Universe is a subtype of ImplicitTags"] ;node19 -> node3 [arrowtail="empty", dir="back", id="graph1_19_3", class="inheritance", tooltip="Universe is a subtype of StandardDefinitions"] ;node2 -> node3 [arrowtail="empty", dir="back", id="graph1_2_3", class="inheritance", tooltip="Universe is a subtype of StandardNames"] ;node11 -> node3 [arrowtail="empty", dir="back", id="graph1_11_3", class="inheritance", tooltip="Universe is a subtype of StandardLiftables"] ;node1 -> node3 [arrowtail="empty", dir="back", id="graph1_1_3", class="inheritance", tooltip="Universe is a subtype of Mirrors"] ;node20 -> node3 [arrowtail="empty", dir="back", id="graph1_20_3", class="inheritance", tooltip="Universe is a subtype of Printers"] ;node21 -> node3 [arrowtail="empty", dir="back", id="graph1_21_3", class="inheritance", tooltip="Universe is a subtype of Liftables"] ;node12 -> node3 [arrowtail="empty", dir="back", id="graph1_12_3", class="inheritance", tooltip="Universe is a subtype of Quasiquotes"] ;node8 -> node3 [arrowtail="empty", dir="back", id="graph1_8_3", class="inheritance", tooltip="Universe is a subtype of Internals"] ;
}
</script><script>$("#inheritance-diagram").bind('beforeShow', function() {
  if ($("svg#graph1").children().length == 0) {
    var dot = document.querySelector("#dot1").text;
    var svg = d3.select("#graph1");
    var inner = svg.append("g");

    // Set up zoom support
    var zoom = d3.zoom()
        .on("zoom", function() {
          inner.attr("transform", d3.event.transform);
        });
    svg.call(zoom);

    var render = new dagreD3.render();
    var g = graphlibDot.read(dot);
    render(inner, g);

    inner.selectAll("g.node").each(function(v) {
      // https://stackoverflow.com/questions/27381452/wrapping-existing-inline-svg-g-element-with-a-element
      var tgt = $("#"+ g.node(v).id +" g.label text")[0];
      var parent = tgt.parentNode;
      var a = document.createElementNS('http://www.w3.org/2000/svg', 'a');
      a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', g.node(v).URL);
      a.appendChild(tgt);
      parent.appendChild(a);
    });
  }
})</script></div></div></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="scala.reflect.api.Annotations" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="AnnotationsextendsAnyRef" class="anchorToMember"></a><a id="Annotations:Annotations" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Annotations.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Annotations.html" title="EXPERIMENTAL"><span class="name">Annotations</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> This trait provides annotation support for the reflection API.</p><p> In Scala, annotations belong to one of the two categories:</p><ul><li><i>Java annotations</i>: annotations on definitions produced by the Java compiler, i.e., subtypes of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html" name="java.lang.annotation.Annotation" id="java.lang.annotation.Annotation" class="extype">java.lang.annotation.Annotation</a>
 attached to program definitions.</li><li><i>Scala annotations</i>: annotations on definitions or types produced by the Scala compiler.</li></ul><p> When a Scala annotation that inherits from <a href="https://www.scala-lang.org/api/2.13.12/scala/annotation/StaticAnnotation.html" name="scala.annotation.StaticAnnotation" id="scala.annotation.StaticAnnotation" class="extype">scala.annotation.StaticAnnotation</a> is compiled,
 it is stored as special attributes in the corresponding classfile, and not as a Java annotation. Note that subclassing
 just <a href="https://www.scala-lang.org/api/2.13.12/scala/annotation/Annotation.html" name="scala.annotation.Annotation" id="scala.annotation.Annotation" class="extype">scala.annotation.Annotation</a> is not enough to have the corresponding metadata persisted for runtime reflection.</p><p> Both Java and Scala annotations are represented as typed trees carrying constructor invocations corresponding
 to the annotation. For instance, the annotation in <code>@ann(1, 2) class C</code> is represented as <code>q"@new ann(1, 2)"</code>.</p><p> Unlike Java reflection, Scala reflection does not support evaluation of constructor invocations stored in annotations
 into underlying objects. For instance it's impossible to go from <code>@ann(1, 2) class C</code> to <code>ann(1, 2)</code>, so one
 has to analyze trees representing annotation arguments to manually extract corresponding values. Towards that end,
 arguments of an annotation can be obtained via <code>annotation.tree.children.tail</code>.</p><p> For more information about <code>Annotation</code>s, see the <a href="https://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html" target="_blank">Reflection Guide: Annotations, Names, Scopes, and More</a>
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Constants" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="ConstantsextendsAnyRef" class="anchorToMember"></a><a id="Constants:Constants" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Constants.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Constants.html" title="EXPERIMENTAL"><span class="name">Constants</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> According to the section 6.24 "Constant Expressions" of the Scala language specification,
 certain expressions (dubbed <i>constant expressions</i>) can be evaluated by the Scala compiler at compile-time.
 Examples include "true", "0" and "classOf[List]".</p><p> <code>Constant</code> instances can be matched against and can be constructed directly, as if they were case classes:</p><pre>assert(Constant(<span class="kw">true</span>).value == <span class="kw">true</span>)
Constant(<span class="kw">true</span>) <span class="kw">match</span> {
  <span class="kw">case</span> Constant(s: <span class="std">String</span>) <span class="kw">=&gt;</span>  println(<span class="lit">"A string: "</span> + s)
  <span class="kw">case</span> Constant(b: <span class="std">Boolean</span>) <span class="kw">=&gt;</span> println(<span class="lit">"A boolean value: "</span> + b)
  <span class="kw">case</span> Constant(x) <span class="kw">=&gt;</span>          println(<span class="lit">"Something else: "</span> + x)
}</pre><p> <code>Constant</code> instances can wrap the following kinds of expressions:</p><ol class="decimal"><li>Literals of primitive value classes (<a href="https://www.scala-lang.org/api/2.13.12/scala/Byte.html" name="scala.Byte" id="scala.Byte" class="extype"><code>Byte</code></a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Short.html" name="scala.Short" id="scala.Short" class="extype"><code>Short</code></a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Int.html" name="scala.Int" id="scala.Int" class="extype"><code>Int</code></a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Long.html" name="scala.Long" id="scala.Long" class="extype"><code>Long</code></a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Float.html" name="scala.Float" id="scala.Float" class="extype"><code>Float</code></a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Double.html" name="scala.Double" id="scala.Double" class="extype"><code>Double</code></a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Char.html" name="scala.Char" id="scala.Char" class="extype"><code>Char</code></a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype"><code>Boolean</code></a> and <a href="https://www.scala-lang.org/api/2.13.12/scala/Unit.html" name="scala.Unit" id="scala.Unit" class="extype"><code>Unit</code></a>) - represented directly as the corresponding type</li><li>String literals - represented as instances of <code>String</code>.</li><li>References to classes, typically constructed with <a href="https://www.scala-lang.org/api/2.13.12/scala/Predef$.html#classOf[T]:Class[T]" name="scala.Predef" id="scala.Predef" class="extype">scala.Predef#classOf</a> - represented as <a href="Types$Type.html" name="scala.reflect.api.Types.Type" id="scala.reflect.api.Types.Type" class="extype">types</a>.</li><li>References to enumeration values - represented as <a href="Symbols$Symbol.html" name="scala.reflect.api.Symbols.Symbol" id="scala.reflect.api.Symbols.Symbol" class="extype">symbols</a>.</li></ol><p> Instances are used to represent literals in abstract syntax trees, inside <a href="Trees$Literal.html" name="scala.reflect.api.Trees.Literal" id="scala.reflect.api.Trees.Literal" class="extype">scala.reflect.api.Trees#Literal</a> nodes.</p><h5> Example </h5><p> The <code>value</code> field deserves some explanation. Primitive and string values are represented as themselves, whereas
 references to classes and enums are a bit roundabout.</p><p> Class references are represented as instances of <a href="Types$Type.html" name="scala.reflect.api.Types.Type" id="scala.reflect.api.Types.Type" class="extype">scala.reflect.api.Types#Type</a>
 (because when the Scala compiler processes a class reference, the underlying runtime class might not yet have been compiled).
 To convert such a reference to a runtime class, one should use the <code>runtimeClass</code> method of a mirror such as <a href="Mirrors$RuntimeMirror.html" name="scala.reflect.api.Mirrors.RuntimeMirror" id="scala.reflect.api.Mirrors.RuntimeMirror" class="extype">scala.reflect.api.Mirrors#RuntimeMirror</a>
 (the simplest way to get such a mirror is using <a href="../runtime/index.html#currentMirror:scala.reflect.runtime.package.universe.Mirror" name="scala.reflect.runtime#currentMirror" id="scala.reflect.runtime#currentMirror" class="extmbr">scala.reflect.runtime.package#currentMirror</a>).</p><p> Enumeration value references are represented as instances of <a href="Symbols$Symbol.html" name="scala.reflect.api.Symbols.Symbol" id="scala.reflect.api.Symbols.Symbol" class="extype">scala.reflect.api.Symbols#Symbol</a>, which on JVM point to methods
 that return underlying enum values. To inspect an underlying enumeration or to get runtime value of a reference to an enum,
 one should use a <a href="Mirrors$RuntimeMirror.html" name="scala.reflect.api.Mirrors.RuntimeMirror" id="scala.reflect.api.Mirrors.RuntimeMirror" class="extype">scala.reflect.api.Mirrors#RuntimeMirror</a> (the simplest way to get such a mirror is again <a href="../runtime/index.html#currentMirror:scala.reflect.runtime.package.universe.Mirror" name="scala.reflect.runtime#currentMirror" id="scala.reflect.runtime#currentMirror" class="extmbr">scala.reflect.runtime.package#currentMirror</a>).</p><pre><span class="cmt">// File "JavaSimpleEnumeration.java"</span>
enum JavaSimpleEnumeration { FOO, BAR }

<span class="cmt">// File "JavaSimpleAnnotation.java"</span>
<span class="kw">import</span> java.lang.annotation.*;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface JavaSimpleAnnotation {
  <span class="std">Class</span>&lt;?&gt; classRef();
  JavaSimpleEnumeration enumRef();
}

<span class="cmt">// File "JavaAnnottee.java"</span>
@JavaSimpleAnnotation(
  classRef = JavaAnnottee.<span class="kw">class</span>,
  enumRef = JavaSimpleEnumeration.BAR
)
public <span class="kw">class</span> JavaAnnottee {}</pre><pre><span class="kw">val</span> javaArgs = typeOf[JavaAnnottee].typeSymbol.annotations(<span class="num">0</span>).tree.children.tail

<span class="kw">def</span> jArg[A](lhs: <span class="std">String</span>): <span class="std">Option</span>[A] = javaArgs
  .map { <span class="kw">case</span> NamedArg(lhs, Literal(const)) <span class="kw">=&gt;</span> (lhs.toString, const) }
  .find(_._1 == lhs)
  .map(_._2.value.asInstanceOf[A])

<span class="cmt">// class reference, cast to Type</span>
<span class="kw">val</span> classRef = jArg[Type](<span class="lit">"classRef"</span>).get
println(showRaw(classRef))             <span class="cmt">// TypeRef(ThisType(&lt;empty&gt;), JavaAnnottee, List())</span>
println(cm.runtimeClass(classRef))     <span class="cmt">// class JavaAnnottee</span>
<span class="cmt">// enum value reference, cast to Symbol</span>
<span class="kw">val</span> enumRef = jArg[<span class="std">Symbol</span>](<span class="lit">"enumRef"</span>).get
println(enumRef)                       <span class="cmt">// value BAR</span>

<span class="kw">val</span> siblings = enumRef.owner.info.decls
<span class="kw">val</span> enumValues = siblings.filter(_.isJavaEnum)
println(enumValues)                    <span class="cmt">// Scope{</span>
                                       <span class="cmt">//   final val FOO: JavaSimpleEnumeration;</span>
                                       <span class="cmt">//   final val BAR: JavaSimpleEnumeration</span>
                                       <span class="cmt">// }</span>

<span class="cmt">// doesn't work because of https://github.com/scala/bug/issues/6459</span>
<span class="cmt">// val enumValue = mirror.reflectField(enumRef.asTerm).get</span>
<span class="kw">val</span> enumClass = cm.runtimeClass(enumRef.owner.asClass)
<span class="kw">val</span> enumValue = enumClass.getDeclaredField(enumRef.name.toString).get(<span class="kw">null</span>)
println(enumValue)                     <span class="cmt">// BAR</span></pre></div></div></li><li class="indented0 " name="scala.reflect.api.Exprs" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="ExprsextendsAnyRef" class="anchorToMember"></a><a id="Exprs:Exprs" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Exprs.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Exprs.html" title="EXPERIMENTAL"><span class="name">Exprs</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>A trait that defines strongly-typed tree wrappers and operations on them for use in Scala Reflection.</p><p> <code>Expr</code> wraps an abstract syntax tree (<a href="Trees$Tree.html" name="scala.reflect.api.Trees.Tree" id="scala.reflect.api.Trees.Tree" class="extype">scala.reflect.api.Trees#Tree</a>) and tags it with its type (<a href="Types$Type.html" name="scala.reflect.api.Types.Type" id="scala.reflect.api.Types.Type" class="extype">scala.reflect.api.Types#Type</a>).</p><p> Usually <code>Expr</code>s are created via <a href="Universe.html#reify[T](expr:T):Universe.this.Expr[T]" name="scala.reflect.api.Universe#reify" id="scala.reflect.api.Universe#reify" class="extmbr">scala.reflect.api.Universe#reify</a>, in which case a compiler
 produces a <a href="TreeCreator.html" name="scala.reflect.api.TreeCreator" id="scala.reflect.api.TreeCreator" class="extype">scala.reflect.api.TreeCreator</a> for the provided expression and also
 creates a complementary <a href="TypeTags$WeakTypeTag.html" name="scala.reflect.api.TypeTags.WeakTypeTag" id="scala.reflect.api.TypeTags.WeakTypeTag" class="extype">scala.reflect.api.TypeTags#WeakTypeTag</a> that corresponds to the type of that expression.</p><p><code>Expr</code>s can also be created manually via the <code>Expr</code> companion object, but then the burden of providing a <code>TreeCreator</code> lies on the programmer.
 Compile-time reflection via macros, as described in <a href="../macros/Aliases.html" name="scala.reflect.macros.Aliases" id="scala.reflect.macros.Aliases" class="extype">scala.reflect.macros.Aliases</a>, provides an easier way to instantiate exprs manually.
 Manual creation, however, is very rarely needed when working with runtime reflection.</p><p> <code>Expr</code> can be migrated from one mirror to another by using the <code>in</code> method. Migration means that all symbolic references
 to classes/objects/packages in the expression are re-resolved within the new mirror
 (typically using that mirror's classloader). The default universe of an <code>Expr</code> is typically
 <a href="../runtime/index.html#universe:scala.reflect.api.JavaUniverse" name="scala.reflect.runtime#universe" id="scala.reflect.runtime#universe" class="extmbr">scala.reflect.runtime#universe</a>, the default mirror is typically <a href="../runtime/index.html#currentMirror:scala.reflect.runtime.package.universe.Mirror" name="scala.reflect.runtime#currentMirror" id="scala.reflect.runtime#currentMirror" class="extmbr">scala.reflect.runtime#currentMirror</a>.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.FlagSets" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="FlagSetsextendsAnyRef" class="anchorToMember"></a><a id="FlagSets:FlagSets" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/FlagSets.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="FlagSets.html" title="EXPERIMENTAL"><span class="name">FlagSets</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>The trait that defines flag sets and operations on them.</p><p><code>Flag</code>s are used to provide modifiers for abstract syntax trees that represent definitions
via the <code>flags</code> field of <a href="Trees.html#Modifiers&gt;:Null&lt;:Trees.this.ModifiersApi" name="scala.reflect.api.Trees.Modifiers" id="scala.reflect.api.Trees.Modifiers" class="extmbr">scala.reflect.api.Trees#Modifiers</a>. Trees that accept modifiers are:</p><ul><li><b><a href="Trees$ClassDef.html" name="scala.reflect.api.Trees.ClassDef" id="scala.reflect.api.Trees.ClassDef" class="extype">scala.reflect.api.Trees#ClassDef</a></b>. Classes and traits.</li><li><b><a href="Trees$ModuleDef.html" name="scala.reflect.api.Trees.ModuleDef" id="scala.reflect.api.Trees.ModuleDef" class="extype">scala.reflect.api.Trees#ModuleDef</a></b>. Objects.</li><li><b><a href="Trees$ValDef.html" name="scala.reflect.api.Trees.ValDef" id="scala.reflect.api.Trees.ValDef" class="extype">scala.reflect.api.Trees#ValDef</a></b>. Vals, vars, parameters and self-type annotations.</li><li><b><a href="Trees$DefDef.html" name="scala.reflect.api.Trees.DefDef" id="scala.reflect.api.Trees.DefDef" class="extype">scala.reflect.api.Trees#DefDef</a></b>. Methods and constructors.</li><li><b><a href="Trees$TypeDef.html" name="scala.reflect.api.Trees.TypeDef" id="scala.reflect.api.Trees.TypeDef" class="extype">scala.reflect.api.Trees#TypeDef</a></b>. Type aliases, abstract type members and type parameters.</li></ul><p>For example, to create a class named <code>C</code> one would write something like:</p><pre>ClassDef(Modifiers(NoFlags), TypeName(<span class="lit">"C"</span>), Nil, ...)</pre><p>Here, the flag set is empty.</p><p>To make <code>C</code> private, one would write something like:</p><pre>ClassDef(Modifiers(PRIVATE), TypeName(<span class="lit">"C"</span>), Nil, ...)</pre><p>Flags can also be combined with the vertical bar operator (<code>|</code>).
For example, a private final class is written something like:</p><pre>ClassDef(Modifiers(PRIVATE | FINAL), TypeName(<span class="lit">"C"</span>), Nil, ...)</pre><p>The list of all available flags is defined in <a href="FlagSets$FlagValues.html" name="scala.reflect.api.FlagSets.FlagValues" id="scala.reflect.api.FlagSets.FlagValues" class="extype">scala.reflect.api.FlagSets#FlagValues</a>, available via
<a href="FlagSets.html#Flag:FlagSets.this.FlagValues" name="scala.reflect.api.FlagSets#Flag" id="scala.reflect.api.FlagSets#Flag" class="extmbr">scala.reflect.api.FlagSets#Flag</a>. (Typically one writes a wildcard import for this, e.g.
<code>import scala.reflect.runtime.universe.Flag._</code>).</p><p>Definition trees are compiled down to symbols, so flags on modifiers of these trees are transformed into flags
on the resulting symbols. Unlike trees, symbols don't expose flags, but rather provide <code>isXXX</code> test methods
(e.g. <code>isFinal</code> can be used to test finality). These test methods might require an upcast with <code>asTerm</code>,
<code>asType</code> or <code>asClass</code> as some flags only make sense for certain kinds of symbols.</p><p><i>Of Note:</i> This part of the Reflection API is being considered as a candidate for redesign. It is
quite possible that in future releases of the reflection API, flag sets could be replaced with something else.</p><p>For more details about <code>FlagSet</code>s and other aspects of Scala reflection, see the
<a href="https://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a>
</p></div></div></li><li class="indented0 " name="scala.reflect.api.ImplicitTags" group="Tags" fullComment="yes" data-isabs="true" visbl="pub"><a id="ImplicitTagsextendsAnyRef" class="anchorToMember"></a><a id="ImplicitTags:ImplicitTags" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/ImplicitTags.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="ImplicitTags.html" title="Tags which preserve the identity of abstract types in the face of erasure."><span class="name">ImplicitTags</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt">Tags which preserve the identity of abstract types in the face of erasure.</p><div class="fullcomment"><div class="comment cmt"><p>Tags which preserve the identity of abstract types in the face of erasure.
 Can be used for pattern matching, instance tests, serialization and the like.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Internals" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="InternalsextendsAnyRef" class="anchorToMember"></a><a id="Internals:Internals" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Internals.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Internals.html" title="EXPERIMENTAL"><span class="name">Internals</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> This trait assembles APIs occasionally necessary for performing low-level operations on reflection artifacts.
 See <a href="Internals$InternalApi.html" name="scala.reflect.api.Internals.InternalApi" id="scala.reflect.api.Internals.InternalApi" class="extype">Internals#InternalApi</a> for more information about nature, usefulness and compatibility guarantees of these APIs.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.JavaUniverse" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="JavaUniverseextendsUniverse" class="anchorToMember"></a><a id="JavaUniverse:JavaUniverse" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/JavaUniverse.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="JavaUniverse.html" title="EXPERIMENTAL"><span class="name">JavaUniverse</span></a><span class="result"> extends <a href="Universe.html" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">Universe</a></span></span><p class="shortcomment cmt"> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> A refinement of <a href="Universe.html" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a> for runtime reflection using JVM classloaders.</p><p> This refinement equips mirrors with reflection capabilities for the JVM. <code>JavaMirror</code> can
 convert Scala reflection artifacts (symbols and types) into Java reflection artifacts (classes)
 and vice versa. It can also perform reflective invocations (getting/setting field values,
 calling methods, etc).</p><p> See the <a href="https://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a> for details on how to use runtime reflection.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Liftables" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="LiftablesextendsAnyRef" class="anchorToMember"></a><a id="Liftables:Liftables" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Liftables.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Liftables.html" title=""><span class="name">Liftables</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></li><li class="indented0 " name="scala.reflect.api.Mirror" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="Mirror[U&lt;:scala.reflect.api.UniversewithSingleton]extendsAnyRef" class="anchorToMember"></a><a id="Mirror[U&lt;:UniversewithSingleton]:Mirror[U]" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Mirror.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="Mirror.html" title="EXPERIMENTAL"><span class="name">Mirror</span></a><span class="tparams">[<span name="U">U &lt;: <a href="Universe.html" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">Universe</a> with <span name="scala.Singleton" class="extype">Singleton</span></span>]</span><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>The base class for all mirrors.</p><p>See <a href="Mirrors.html" name="scala.reflect.api.Mirrors" id="scala.reflect.api.Mirrors" class="extype">scala.reflect.api.Mirrors</a> or <a href="https://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a>
for a complete overview of <code>Mirror</code>s.
</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>the type of the universe this mirror belongs to.</p></dd></dl></div></li><li class="indented0 " name="scala.reflect.api.Mirrors" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="MirrorsextendsAnyRef" class="anchorToMember"></a><a id="Mirrors:Mirrors" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Mirrors.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Mirrors.html" title="EXPERIMENTAL"><span class="name">Mirrors</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>This trait provides support for Mirrors in the Scala Reflection API.</p><p><code>Mirror</code>s are a central part of Scala Reflection. All information provided by
reflection is made accessible through <code>Mirror</code>s. Depending on the type of information
to be obtained, or the reflective action to be taken, different flavors of mirrors
must be used. "Classloader" mirrors can be used to obtain representations of types
and members. From a classloader <code>Mirror</code>, it's possible to obtain more specialized
"invoker" <code>Mirror</code>s (the most commonly-used mirrors), which implement reflective
invocations, such as method/constructor calls and field accesses.</p><p>The two flavors of mirrors:</p><ul><li><b>“Classloader” mirrors</b>. These mirrors translate names to symbols
(via methods <code>staticClass</code>/<code>staticModule</code>/<code>staticPackage</code>).</li><li><b>"Invoker” mirrors</b>. These mirrors implement reflective invocations
(via methods <code>MethodMirror.apply</code>, <code>FieldMirror.get</code>, etc). These "invoker"
mirrors are the types of mirrors that are most commonly used.</li></ul><h5> Compile-time Mirrors </h5><p>Compile-time <code>Mirror</code>s make use of only classloader <code>Mirror</code>s to load <code>Symbol</code>s
by name.</p><p>The entry point to classloader <code>Mirror</code>s is via <a href="../macros/blackbox/Context.html#mirror:Context.this.universe.Mirror" name="scala.reflect.macros.blackbox.Context#mirror" id="scala.reflect.macros.blackbox.Context#mirror" class="extmbr">scala.reflect.macros.blackbox.Context#mirror</a> or <a href="../macros/whitebox/Context.html#mirror:Context.this.universe.Mirror" name="scala.reflect.macros.whitebox.Context#mirror" id="scala.reflect.macros.whitebox.Context#mirror" class="extmbr">scala.reflect.macros.whitebox.Context#mirror</a>.
Typical methods which use classloader <code>Mirror</code>s include <a href="Mirror.html#staticClass(fullName:String):U#ClassSymbol" name="scala.reflect.api.Mirror#staticClass" id="scala.reflect.api.Mirror#staticClass" class="extmbr">scala.reflect.api.Mirror#staticClass</a>,
<a href="Mirror.html#staticModule(fullName:String):U#ModuleSymbol" name="scala.reflect.api.Mirror#staticModule" id="scala.reflect.api.Mirror#staticModule" class="extmbr">scala.reflect.api.Mirror#staticModule</a>, and <a href="Mirror.html#staticPackage(fullName:String):U#ModuleSymbol" name="scala.reflect.api.Mirror#staticPackage" id="scala.reflect.api.Mirror#staticPackage" class="extmbr">scala.reflect.api.Mirror#staticPackage</a>. For
example:</p><pre><span class="kw">import</span> scala.reflect.macros.blackbox.Context

<span class="kw">case</span> <span class="kw">class</span> Location(filename: <span class="std">String</span>, line: <span class="std">Int</span>, column: <span class="std">Int</span>)

<span class="kw">object</span> Macros {
  <span class="kw">def</span> currentLocation: Location = macro impl

  <span class="kw">def</span> impl(c: Context): c.Expr[Location] = {
    <span class="kw">import</span> c.universe._
    <span class="kw">val</span> pos = c.macroApplication.pos
    <span class="kw">val</span> clsLocation = c.mirror.staticModule(<span class="lit">"Location"</span>) <span class="cmt">// get symbol of "Location" object</span>
    c.Expr(Apply(Ident(clsLocation), <span class="std">List</span>(Literal(Constant(pos.source.path)), Literal(Constant(pos.line)), Literal(Constant(pos.column)))))
  }
}</pre><p><i>Of Note:</i> There are several high-level alternatives that one can use to avoid having to manually
lookup symbols. For example, <code>typeOf[Location.type].termSymbol</code> (or <code>typeOf[Location].typeSymbol</code>
if we needed a <code>ClassSymbol</code>), which are type safe since we don’t have to use <code>String</code>s to lookup
the <code>Symbol</code>.</p><h5> Runtime Mirrors </h5><p>Runtime <code>Mirror</code>s make use of both classloader and invoker <code>Mirror</code>s.</p><p>The entry point to <code>Mirror</code>s for use at runtime is via <code>ru.runtimeMirror(&lt;classloader&gt;)</code>, where
<code>ru</code> is <a href="../runtime/index.html#universe:scala.reflect.api.JavaUniverse" name="scala.reflect.runtime#universe" id="scala.reflect.runtime#universe" class="extmbr">scala.reflect.runtime.universe</a>.</p><p>The result of a <a href="JavaUniverse.html#runtimeMirror(cl:ClassLoader):JavaUniverse.this.Mirror" name="scala.reflect.api.JavaUniverse#runtimeMirror" id="scala.reflect.api.JavaUniverse#runtimeMirror" class="extmbr">scala.reflect.api.JavaUniverse#runtimeMirror</a> call is a classloader mirror,
of type <a href="Mirrors$ReflectiveMirror.html" name="scala.reflect.api.Mirrors.ReflectiveMirror" id="scala.reflect.api.Mirrors.ReflectiveMirror" class="extype">scala.reflect.api.Mirrors#ReflectiveMirror</a>, which can load symbols by names as
discussed above (in the “Compile-time” section).</p><p>A classloader mirror can create invoker mirrors, which include: <a href="Mirrors$InstanceMirror.html" name="scala.reflect.api.Mirrors.InstanceMirror" id="scala.reflect.api.Mirrors.InstanceMirror" class="extype">scala.reflect.api.Mirrors#InstanceMirror</a>,
<a href="Mirrors$MethodMirror.html" name="scala.reflect.api.Mirrors.MethodMirror" id="scala.reflect.api.Mirrors.MethodMirror" class="extype">scala.reflect.api.Mirrors#MethodMirror</a>, <a href="Mirrors$FieldMirror.html" name="scala.reflect.api.Mirrors.FieldMirror" id="scala.reflect.api.Mirrors.FieldMirror" class="extype">scala.reflect.api.Mirrors#FieldMirror</a>,
<a href="Mirrors$ClassMirror.html" name="scala.reflect.api.Mirrors.ClassMirror" id="scala.reflect.api.Mirrors.ClassMirror" class="extype">scala.reflect.api.Mirrors#ClassMirror</a> and <a href="Mirrors$ModuleMirror.html" name="scala.reflect.api.Mirrors.ModuleMirror" id="scala.reflect.api.Mirrors.ModuleMirror" class="extype">scala.reflect.api.Mirrors#ModuleMirror</a>.</p><p>Examples of how these two types of <code>Mirror</code>s interact are available below.</p><h5> Types of Mirrors, Their Use Cases &amp; Examples </h5><p><b><a href="Mirrors$ReflectiveMirror.html" name="scala.reflect.api.Mirrors.ReflectiveMirror" id="scala.reflect.api.Mirrors.ReflectiveMirror" class="extype">scala.reflect.api.Mirrors#ReflectiveMirror</a></b>. Used for loading <code>Symbol</code>s by name, and
as an entry point into invoker mirrors. Entry point: <code>val m = ru.runtimeMirror(&lt;classloader&gt;)</code>.
Example:</p><pre>scala&gt; <span class="kw">val</span> ru = scala.reflect.runtime.universe
ru: scala.reflect.api.JavaUniverse = ...

scala&gt; <span class="kw">val</span> m = ru.runtimeMirror(getClass.getClassLoader)
m: reflect.runtime.universe.Mirror = JavaMirror ...</pre><p><b><a href="Mirrors$InstanceMirror.html" name="scala.reflect.api.Mirrors.InstanceMirror" id="scala.reflect.api.Mirrors.InstanceMirror" class="extype">scala.reflect.api.Mirrors#InstanceMirror</a></b>. Used for creating invoker <code>Mirror</code>s for methods
and fields and for inner classes and inner objects (modules). Entry point: <code>val im = m.reflect(&lt;value&gt;)</code>.
Example:</p><pre>scala&gt; <span class="kw">class</span> C { <span class="kw">def</span> x = <span class="num">2</span> }
defined <span class="kw">class</span> C

scala&gt; <span class="kw">val</span> im = m.reflect(<span class="kw">new</span> C)
im: reflect.runtime.universe.InstanceMirror = instance mirror <span class="kw">for</span> C@<span class="num">3442299</span>e</pre><p><b><a href="Mirrors$MethodMirror.html" name="scala.reflect.api.Mirrors.MethodMirror" id="scala.reflect.api.Mirrors.MethodMirror" class="extype">scala.reflect.api.Mirrors#MethodMirror</a></b>. Used for invoking instance methods (Scala only has
instance methods-- methods of objects are instance methods of object instances, obtainable
via <code>ModuleMirror.instance</code>). Entry point: <code>val mm = im.reflectMethod(&lt;method symbol&gt;)</code>.
Example:</p><pre>scala&gt; <span class="kw">val</span> methodX = typeOf[C].decl(TermName(<span class="lit">"x"</span>)).asMethod
methodX: reflect.runtime.universe.MethodSymbol = method x

scala&gt; <span class="kw">val</span> mm = im.reflectMethod(methodX)
mm: reflect.runtime.universe.MethodMirror = method mirror <span class="kw">for</span> C.x: scala.<span class="std">Int</span> (bound to C@<span class="num">3442299</span>e)

scala&gt; mm()
res0: <span class="std">Any</span> = <span class="num">2</span></pre><p><b><a href="Mirrors$FieldMirror.html" name="scala.reflect.api.Mirrors.FieldMirror" id="scala.reflect.api.Mirrors.FieldMirror" class="extype">scala.reflect.api.Mirrors#FieldMirror</a></b>. Used for getting/setting instance fields
(Scala only has instance fields-- fields of objects are instance methods of object instances
obtainable via ModuleMirror.instance). Entry point:
<code>val fm = im.reflectMethod(&lt;field or accessor symbol&gt;)</code>.
Example:</p><pre>scala&gt; <span class="kw">class</span> C { <span class="kw">val</span> x = <span class="num">2</span>; <span class="kw">val</span> y = <span class="num">3</span> }
defined <span class="kw">class</span> C

scala&gt; <span class="kw">val</span> m = ru.runtimeMirror(getClass.getClassLoader)
m: reflect.runtime.universe.Mirror = JavaMirror ...

scala&gt; <span class="kw">val</span> im = m.reflect(<span class="kw">new</span> C)
im: reflect.runtime.universe.InstanceMirror = instance mirror <span class="kw">for</span> C@<span class="num">5</span>f0c8ac1

scala&gt; <span class="kw">val</span> fieldX = typeOf[C].decl(TermName(<span class="lit">"x"</span>)).asTerm.accessed.asTerm
fieldX: reflect.runtime.universe.TermSymbol = value x
scala&gt; <span class="kw">val</span> fmX = im.reflectField(fieldX)
fmX: reflect.runtime.universe.FieldMirror = field mirror <span class="kw">for</span> C.x (bound to C@<span class="num">5</span>f0c8ac1)

scala&gt; fmX.get
res0: <span class="std">Any</span> = <span class="num">2</span>

scala&gt; fmX.set(<span class="num">3</span>) <span class="cmt">// NOTE: can set an underlying value of an immutable field!</span>

scala&gt; <span class="kw">val</span> fieldY = typeOf[C].decl(TermName(<span class="lit">"y"</span>)).asTerm.accessed.asTerm
fieldY: reflect.runtime.universe.TermSymbol = variable y

scala&gt; <span class="kw">val</span> fmY = im.reflectField(fieldY)
fmY: reflect.runtime.universe.FieldMirror = field mirror <span class="kw">for</span> C.y (bound to C@<span class="num">5</span>f0c8ac1)

scala&gt; fmY.get
res1: <span class="std">Any</span> = <span class="num">3</span>

scala&gt; fmY.set(<span class="num">4</span>)

scala&gt; fmY.get
res2: <span class="std">Any</span> = <span class="num">4</span></pre><p><b><a href="Mirrors$ClassMirror.html" name="scala.reflect.api.Mirrors.ClassMirror" id="scala.reflect.api.Mirrors.ClassMirror" class="extype">scala.reflect.api.Mirrors#ClassMirror</a></b>. Used for creating invoker mirrors for constructors.
Entry points: for <i>static classes</i> <code>val cm1 = m.reflectClass(&lt;class symbol&gt;)</code>,
for <i>inner classes</i> <code>val mm2 = im.reflectClass(&lt;class symbol&gt;)</code>.
Example:</p><pre>scala&gt; <span class="kw">case</span> <span class="kw">class</span> C(x: <span class="std">Int</span>)
defined <span class="kw">class</span> C

scala&gt; <span class="kw">val</span> m = ru.runtimeMirror(getClass.getClassLoader)
m: reflect.runtime.universe.Mirror = JavaMirror ...

scala&gt; <span class="kw">val</span> classC = typeOf[C].typeSymbol.asClass

classC: reflect.runtime.universe.<span class="std">Symbol</span> = <span class="kw">class</span> C

scala&gt; <span class="kw">val</span> cm = m.reflectClass(classC)
cm: reflect.runtime.universe.ClassMirror = <span class="kw">class</span> mirror <span class="kw">for</span> C (bound to <span class="kw">null</span>)

scala&gt; <span class="kw">val</span> ctorC = typeOf[C].decl(ru.nme.CONSTRUCTOR).asMethod
ctorC: reflect.runtime.universe.MethodSymbol = constructor C

scala&gt; <span class="kw">val</span> ctorm = cm.reflectConstructor(ctorC)
ctorm: reflect.runtime.universe.MethodMirror = constructor mirror <span class="kw">for</span> C.&lt;init&gt;(x: scala.<span class="std">Int</span>): C (bound to <span class="kw">null</span>)

scala&gt; ctorm(<span class="num">2</span>)
res0: <span class="std">Any</span> = C(<span class="num">2</span>)</pre><p><b><a href="Mirrors$ModuleMirror.html" name="scala.reflect.api.Mirrors.ModuleMirror" id="scala.reflect.api.Mirrors.ModuleMirror" class="extype">scala.reflect.api.Mirrors#ModuleMirror</a></b>. Used for getting singleton instances of objects.
Entry points: for <i>static objects (modules)</i> <code>val mm1 = m.reflectModule(&lt;module symbol&gt;)</code>,
for <i>inner objects (modules)</i> <code>val mm2 = im.reflectModule(&lt;module symbol&gt;)</code>.
Example:</p><pre>scala&gt; <span class="kw">object</span> C { <span class="kw">def</span> x = <span class="num">2</span> }
defined module C

scala&gt; <span class="kw">val</span> m = ru.runtimeMirror(getClass.getClassLoader)
m: reflect.runtime.universe.Mirror = JavaMirror ...

scala&gt; <span class="kw">val</span> objectC = typeOf[C.<span class="kw">type</span>].termSymbol.asModule
objectC: reflect.runtime.universe.ModuleSymbol = <span class="kw">object</span> C

scala&gt; <span class="kw">val</span> mm = m.reflectModule(objectC)
mm: reflect.runtime.universe.ModuleMirror = module mirror <span class="kw">for</span> C (bound to <span class="kw">null</span>)

scala&gt; <span class="kw">val</span> obj = mm.instance
obj: <span class="std">Any</span> = C$@<span class="num">1005</span>ec04</pre><p>For more information about <code>Mirrors</code>s, see the
<a href="https://docs.scala-lang.org/overviews/reflection/environment-universes-mirrors.html" target="_blank">Reflection Guide: Mirrors</a>
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Names" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="NamesextendsAnyRef" class="anchorToMember"></a><a id="Names:Names" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Names.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Names.html" title="EXPERIMENTAL"><span class="name">Names</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>This trait defines <code>Name</code>s in Scala Reflection, and operations on them.</p><p> Names are simple wrappers for strings. <a href="Names.html#Name&gt;:Null&lt;:Names.this.NameApi" name="scala.reflect.api.Names.Name" id="scala.reflect.api.Names.Name" class="extmbr">Name</a> has two subtypes
 <a href="Names.html#TermName&gt;:Null&lt;:Names.this.TermNameApiwithNames.this.Name" name="scala.reflect.api.Names.TermName" id="scala.reflect.api.Names.TermName" class="extmbr">TermName</a> and <a href="Names.html#TypeName&gt;:Null&lt;:Names.this.TypeNameApiwithNames.this.Name" name="scala.reflect.api.Names.TypeName" id="scala.reflect.api.Names.TypeName" class="extmbr">TypeName</a>
 which distinguish names of terms (like objects or members) and types. A term and a type of the
 same name can co-exist in an object.</p><p> To search for the <code>map</code> method (which is a term) declared in the <code>List</code> class, one can do:</p><pre>scala&gt; typeOf[<span class="std">List</span>[_]].member(TermName(<span class="lit">"map"</span>))
res0: reflect.runtime.universe.<span class="std">Symbol</span> = method map</pre><p> To search for a type member, one can follow the same procedure, using <code>TypeName</code> instead.</p><p> For more information about creating and using <code>Name</code>s, see the <a href="https://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html" target="_blank">Reflection Guide: Annotations, Names, Scopes, and More</a>
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Position" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="PositionextendsAttachments" class="anchorToMember"></a><a id="Position:Position" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Position.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Position.html" title="EXPERIMENTAL"><span class="name">Position</span></a><span class="result"> extends <a href="../macros/Attachments.html" name="scala.reflect.macros.Attachments" id="scala.reflect.macros.Attachments" class="extype">Attachments</a></span></span><p class="shortcomment cmt"> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> Position tracks the origin of <a href="Symbols$Symbol.html" name="scala.reflect.api.Symbols.Symbol" id="scala.reflect.api.Symbols.Symbol" class="extype">symbols</a> and <a href="Trees$Tree.html" name="scala.reflect.api.Trees.Tree" id="scala.reflect.api.Trees.Tree" class="extype">tree nodes</a>. They are commonly used when
 displaying warnings and errors, to indicate the incorrect point in the program.</p><p> Every non-empty position refers to a SourceFile and three character
 offsets within it: start, end, and point. The point is where the ^ belongs when
 issuing an error message, usually a Name. A range position can be designated
 as transparent, which excuses it from maintaining the invariants to follow. If
 a transparent position has opaque children, those are considered as if they were
 the direct children of the transparent position's parent.</p><p> Note: some of these invariants actually apply to the trees which carry
 the positions, but they are phrased as if the positions themselves were
 the parent/children for conciseness.</p><p> Invariant 1: in a focused/offset position, start == point == end
 Invariant 2: in a range position,          start &lt;= point &lt;  end
 Invariant 3: an offset position never has a child with a range position
 Invariant 4: every range position child of a range position parent is contained within its parent
 Invariant 5: opaque range position siblings overlap at most at a single point</p><p> The following tests are useful on positions:</p><p> pos.isDefined     true if position is not an UndefinedPosition (those being NoPosition and FakePos)
 pos.isRange       true if position is a range (opaque or transparent) which implies start &lt; end
 pos.isOpaqueRange true if position is an opaque range</p><p> The following accessor methods are provided - an exception will be thrown if
 point/start/end are attempted on an UndefinedPosition.</p><p> pos.source       The source file of the position, or NoSourceFile if unavailable
 pos.point        The offset of the point
 pos.start        The (inclusive) start offset, or the point of an offset position
 pos.end          The (exclusive) end offset, or the point of an offset position</p><p> The following conversion methods are often used:</p><p> pos.focus           Converts a range position to an offset position focused on the point
 pos.makeTransparent Convert an opaque range into a transparent range</p><p> For more information about <code>Position</code>s, see the <a href="https://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html" target="_blank">Reflection Guide: Annotations, Names, Scopes, and More</a>
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Positions" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="PositionsextendsAnyRef" class="anchorToMember"></a><a id="Positions:Positions" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Positions.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Positions.html" title="EXPERIMENTAL"><span class="name">Positions</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>This trait defines the concept of positions and operations on them.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="Position.html" name="scala.reflect.api.Position" id="scala.reflect.api.Position" class="extype">scala.reflect.api.Position</a></p></span></dd></dl></div></li><li class="indented0 " name="scala.reflect.api.Printers" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="PrintersextendsAnyRef" class="anchorToMember"></a><a id="Printers:Printers" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Printers.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Printers.html" title="EXPERIMENTAL"><span class="name">Printers</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>Utilities for nicely printing <a href="Trees.html" name="scala.reflect.api.Trees" id="scala.reflect.api.Trees" class="extype">scala.reflect.api.Trees</a> and <a href="Types.html" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a>.</p><h5> Printing Trees </h5><p>The method <code>show</code> displays the "prettified" representation of reflection artifacts.
This representation provides one with the desugared Java representation of Scala code.
For example:</p><pre>scala&gt; <span class="kw">import</span> scala.reflect.runtime.universe._
<span class="kw">import</span> scala.reflect.runtime.universe._

scala&gt; <span class="kw">def</span> tree = reify{ <span class="kw">final</span> <span class="kw">class</span> C { <span class="kw">def</span> x = <span class="num">2</span> } }.tree
tree: reflect.runtime.universe.Tree

scala&gt; show(tree)
res0: <span class="std">String</span> =
{
  <span class="kw">final</span> <span class="kw">class</span> C <span class="kw">extends</span> <span class="std">AnyRef</span> {
    <span class="kw">def</span> &lt;init&gt;() = {
      <span class="kw">super</span>.&lt;init&gt;();
      ()
    };
    <span class="kw">def</span> x = <span class="num">2</span>
  };
  ()
}</pre><p>The method <code>showRaw</code> displays internal structure of a given reflection object
as a Scala abstract syntax tree (AST), the representation that the Scala typechecker
operates on.</p><p>Note, that while this representation appears to generate correct trees that one
might think would be possible to use in a macro implementation, this is not usually
the case. Symbols aren't fully represented (only their names are). Thus, this method
is best-suited for use simply inspecting ASTs given some valid Scala code.</p><pre>scala&gt; showRaw(tree)
res1: <span class="std">String</span> = Block(<span class="std">List</span>(
  ClassDef(Modifiers(FINAL), TypeName(<span class="lit">"C"</span>), <span class="std">List</span>(), Template(
    <span class="std">List</span>(Ident(TypeName(<span class="lit">"AnyRef"</span>))),
    noSelfType,
    <span class="std">List</span>(
      DefDef(Modifiers(), nme.CONSTRUCTOR, <span class="std">List</span>(), <span class="std">List</span>(<span class="std">List</span>()), TypeTree(),
        Block(<span class="std">List</span>(
          Apply(Select(Super(This(tpnme.EMPTY), tpnme.EMPTY), nme.CONSTRUCTOR), <span class="std">List</span>())),
          Literal(Constant(())))),
      DefDef(Modifiers(), TermName(<span class="lit">"x"</span>), <span class="std">List</span>(), <span class="std">List</span>(), TypeTree(),
        Literal(Constant(<span class="num">2</span>))))))),
  Literal(Constant(())))</pre><p>The method <code>showRaw</code> can also print <a href="Types.html" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a> next to the artifacts
being inspected</p><pre>scala&gt; <span class="kw">import</span> scala.tools.reflect.ToolBox <span class="cmt">// requires scala-compiler.jar</span>
<span class="kw">import</span> scala.tools.reflect.ToolBox

scala&gt; <span class="kw">import</span> scala.reflect.runtime.{currentMirror <span class="kw">=&gt;</span> cm}
<span class="kw">import</span> scala.reflect.runtime.{currentMirror<span class="kw">=&gt;</span>cm}

scala&gt; showRaw(cm.mkToolBox().typecheck(tree), printTypes = <span class="kw">true</span>)
res2: <span class="std">String</span> = Block[<span class="num">1</span>](<span class="std">List</span>(
  ClassDef[<span class="num">2</span>](Modifiers(FINAL), TypeName(<span class="lit">"C"</span>), <span class="std">List</span>(), Template[<span class="num">3</span>](
    <span class="std">List</span>(Ident[<span class="num">4</span>](TypeName(<span class="lit">"AnyRef"</span>))),
    noSelfType,
    <span class="std">List</span>(
      DefDef[<span class="num">2</span>](Modifiers(), nme.CONSTRUCTOR, <span class="std">List</span>(), <span class="std">List</span>(<span class="std">List</span>()), TypeTree[<span class="num">3</span>](),
        Block[<span class="num">1</span>](<span class="std">List</span>(
          Apply[<span class="num">4</span>](Select[<span class="num">5</span>](Super[<span class="num">6</span>](This[<span class="num">3</span>](TypeName(<span class="lit">"C"</span>)), tpnme.EMPTY), ...))),
          Literal[<span class="num">1</span>](Constant(())))),
      DefDef[<span class="num">2</span>](Modifiers(), TermName(<span class="lit">"x"</span>), <span class="std">List</span>(), <span class="std">List</span>(), TypeTree[<span class="num">7</span>](),
        Literal[<span class="num">8</span>](Constant(<span class="num">2</span>))))))),
  Literal[<span class="num">1</span>](Constant(())))
[<span class="num">1</span>] TypeRef(ThisType(scala), scala.<span class="std">Unit</span>, <span class="std">List</span>())
[<span class="num">2</span>] NoType
[<span class="num">3</span>] TypeRef(NoPrefix, TypeName(<span class="lit">"C"</span>), <span class="std">List</span>())
[<span class="num">4</span>] TypeRef(ThisType(java.lang), java.lang.<span class="std">Object</span>, <span class="std">List</span>())
[<span class="num">5</span>] MethodType(<span class="std">List</span>(), TypeRef(ThisType(java.lang), java.lang.<span class="std">Object</span>, <span class="std">List</span>()))
[<span class="num">6</span>] SuperType(ThisType(TypeName(<span class="lit">"C"</span>)), TypeRef(... java.lang.<span class="std">Object</span> ...))
[<span class="num">7</span>] TypeRef(ThisType(scala), scala.<span class="std">Int</span>, <span class="std">List</span>())
[<span class="num">8</span>] ConstantType(Constant(<span class="num">2</span>))</pre><h5> Printing Types </h5><p>The method <code>show</code></p><pre>scala&gt; <span class="kw">import</span> scala.reflect.runtime.universe._
<span class="kw">import</span> scala.reflect.runtime.universe._

scala&gt; <span class="kw">def</span> tpe = typeOf[{ <span class="kw">def</span> x: <span class="std">Int</span>; <span class="kw">val</span> y: <span class="std">List</span>[<span class="std">Int</span>] }]
tpe: reflect.runtime.universe.Type

scala&gt; show(tpe)
res0: <span class="std">String</span> = scala.<span class="std">AnyRef</span>{<span class="kw">def</span> x: <span class="std">Int</span>; <span class="kw">val</span> y: scala.<span class="std">List</span>[<span class="std">Int</span>]}</pre><p>Like the method <code>showRaw</code> for <a href="Trees.html" name="scala.reflect.api.Trees" id="scala.reflect.api.Trees" class="extype">scala.reflect.api.Trees</a>, <code>showRaw</code>
for <a href="Types.html" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">scala.reflect.api.Types</a> provides a visualization of the Scala
AST operated on by the Scala typechecker.</p><pre><span class="cmt">// showRaw has already been discussed above</span>
scala&gt; showRaw(tpe)
res1: <span class="std">String</span> = RefinedType(
  <span class="std">List</span>(TypeRef(ThisType(scala), TypeName(<span class="lit">"AnyRef"</span>), <span class="std">List</span>())),
  Scope(
    TermName(<span class="lit">"x"</span>),
    TermName(<span class="lit">"y"</span>)))</pre><p><code>printIds</code> and/or <code>printKinds</code> can additionally be supplied as arguments in a call to
<code>showRaw</code> which additionally shows the unique identifiers of symbols.</p><pre>scala&gt; showRaw(tpe, printIds = <span class="kw">true</span>, printKinds = <span class="kw">true</span>)
res2: <span class="std">String</span> = RefinedType(
  <span class="std">List</span>(TypeRef(ThisType(scala#<span class="num">2043</span>#PK), TypeName(<span class="lit">"AnyRef"</span>)#<span class="num">691</span>#TPE, <span class="std">List</span>())),
  Scope(
    TermName(<span class="lit">"x"</span>)#<span class="num">2540</span>#METH,
    TermName(<span class="lit">"y"</span>)#<span class="num">2541</span>#GET))</pre><p>For more details about <code>Printer</code>s and other aspects of Scala reflection, see the
<a href="https://docs.scala-lang.org/overviews/reflection/overview.html" target="_blank">Reflection Guide</a>
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Quasiquotes" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="QuasiquotesextendsAnyRef" class="anchorToMember"></a><a id="Quasiquotes:Quasiquotes" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Quasiquotes.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Quasiquotes.html" title=""><span class="name">Quasiquotes</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></li><li class="indented0 " name="scala.reflect.api.Scopes" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="ScopesextendsAnyRef" class="anchorToMember"></a><a id="Scopes:Scopes" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Scopes.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Scopes.html" title="EXPERIMENTAL"><span class="name">Scopes</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>This trait provides support for scopes in the reflection API.</p><p>A scope object generally maps names to symbols available in a corresponding lexical scope.
Scopes can be nested. The base type exposed to the reflection API, however,
only exposes a minimal interface, representing a scope as an iterable of symbols.</p><p>For rare occasions when it is necessary to create a scope manually,
e.g., to populate members of <a href="Types$RefinedType.html" name="scala.reflect.api.Types.RefinedType" id="scala.reflect.api.Types.RefinedType" class="extype">scala.reflect.api.Types#RefinedType</a>,
there is the <code>newScopeWith</code> function.</p><p>Additional functionality is exposed in member scopes that are returned by
<code>members</code> and <code>decls</code> defined in <a href="Types$TypeApi.html" name="scala.reflect.api.Types.TypeApi" id="scala.reflect.api.Types.TypeApi" class="extype">scala.reflect.api.Types#TypeApi</a>.
Such scopes support the <code>sorted</code> method, which sorts members in declaration order.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.StandardDefinitions" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="StandardDefinitionsextendsAnyRef" class="anchorToMember"></a><a id="StandardDefinitions:StandardDefinitions" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/StandardDefinitions.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="StandardDefinitions.html" title="EXPERIMENTAL"><span class="name">StandardDefinitions</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>All Scala standard symbols and types.</p><p>These standard definitions can accessed to using <code>definitions</code>.
They're typically imported with a wildcard import, <code>import definitions._</code>, and are
listed in <a href="StandardDefinitions$DefinitionsApi.html" name="scala.reflect.api.StandardDefinitions.DefinitionsApi" id="scala.reflect.api.StandardDefinitions.DefinitionsApi" class="extype">scala.reflect.api.StandardDefinitions#DefinitionsApi</a>.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.StandardLiftables" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="StandardLiftablesextendsAnyRef" class="anchorToMember"></a><a id="StandardLiftables:StandardLiftables" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/StandardLiftables.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="StandardLiftables.html" title=""><span class="name">StandardLiftables</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></li><li class="indented0 " name="scala.reflect.api.StandardNames" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="StandardNamesextendsAnyRef" class="anchorToMember"></a><a id="StandardNames:StandardNames" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/StandardNames.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="StandardNames.html" title="EXPERIMENTAL"><span class="name">StandardNames</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> Standard names are names that are essential to creating trees or to reflecting Scala artifacts.
 For example, <code>CONSTRUCTOR</code> (aka <code>&lt;init&gt;</code> on JVM) is necessary to create and invoke constructors.</p><p> These standard names can be referred to using <a href="StandardNames.html#nme:StandardNames.this.TermNamesApi" name="scala.reflect.api.StandardNames#nme" id="scala.reflect.api.StandardNames#nme" class="extmbr"><code>nme</code></a> for term names and <a href="StandardNames.html#tpnme:StandardNames.this.TypeNamesApi" name="scala.reflect.api.StandardNames#tpnme" id="scala.reflect.api.StandardNames#tpnme" class="extmbr"><code>tpnme</code></a> for type names
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="Names.html" name="scala.reflect.api.Names" id="scala.reflect.api.Names" class="extype">Names</a>
 The API for names in Scala reflection.</p></span></dd></dl></div></li><li class="indented0 " name="scala.reflect.api.Symbols" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="SymbolsextendsAnyRef" class="anchorToMember"></a><a id="Symbols:Symbols" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Symbols.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Symbols.html" title="EXPERIMENTAL"><span class="name">Symbols</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> This trait defines symbols and operations on them.</p><p> Symbols are used to establish bindings between a name and the entity it refers to, such as a class or a method.
 Anything you define and can give a name to in Scala has an associated symbol.</p><p> Symbols contain all available information about the declaration of an entity (class/object/trait etc.) or a
 member (vals/vars/defs etc.), and as such are an integral abstraction central to both runtime
 reflection and macros.</p><p> A symbol can provide a wealth of information ranging from the basic <code>name</code> method available on all symbols to
 other, more involved, concepts such as getting the <code>baseClasses</code> from <code>ClassSymbol</code>. Other common use cases of
 symbols include inspecting members' signatures, getting type parameters of a class, getting the parameter type
 of a method or finding out the type of a field.</p><p> Example usage of runtime reflection; getting a method's type signature:</p><pre>scala&gt; <span class="kw">import</span> scala.reflect.runtime.universe._
<span class="kw">import</span> scala.reflect.runtime.universe._

scala&gt; <span class="kw">class</span> C[T] { <span class="kw">def</span> test[U](x: T)(y: U): <span class="std">Int</span> = ??? }
defined <span class="kw">class</span> C

scala&gt; <span class="kw">val</span> test = typeOf[C[<span class="std">Int</span>]].member(TermName(<span class="lit">"test"</span>)).asMethod
test: reflect.runtime.universe.MethodSymbol = method test

scala&gt; test.info
res0: reflect.runtime.universe.Type = [U](x: T)(y: U)scala.<span class="std">Int</span></pre><p> Symbols are organized in a hierarchy. For example, a symbol that represents a parameter of a method is owned by
 the corresponding method symbol, a method symbol is owned by its enclosing class, a class is owned by a
 containing package and so on.</p><p> Certain types of tree nodes, such as <a href="Trees$Ident.html" name="scala.reflect.api.Trees.Ident" id="scala.reflect.api.Trees.Ident" class="extype">Ident</a> (references to identifiers) and
 <a href="Trees$Select.html" name="scala.reflect.api.Trees.Select" id="scala.reflect.api.Trees.Select" class="extype">Select</a> (references to members) expose method <a href="Trees$SymTreeApi.html#symbol:Trees.this.Symbol" name="scala.reflect.api.Trees.SymTreeApi#symbol" id="scala.reflect.api.Trees.SymTreeApi#symbol" class="extmbr"><code>symbol</code></a>
 to obtain the symbol that represents their declaration. During the typechecking phase, the compiler looks up the
 symbol based on the name and scope and sets the <a href="Trees$SymTreeApi.html#symbol:Trees.this.Symbol" name="scala.reflect.api.Trees.SymTreeApi#symbol" id="scala.reflect.api.Trees.SymTreeApi#symbol" class="extmbr"><code>symbol</code> field</a> of tree nodes.</p><p> For more information about <code>Symbol</code> usage and attached intricacies, see the <a href="https://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" target="_blank">Reflection Guide: Symbols</a>
</p></div></div></li><li class="indented0 " name="scala.reflect.api.TreeCreator" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="TreeCreatorextendsSerializable" class="anchorToMember"></a><a id="TreeCreator:TreeCreator" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/TreeCreator.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="TreeCreator.html" title="A mirror-aware factory for trees."><span class="name">TreeCreator</span></a><span class="result"> extends <a href="../../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span><p class="shortcomment cmt">A mirror-aware factory for trees.</p><div class="fullcomment"><div class="comment cmt"><p>A mirror-aware factory for trees.</p><p>This class is used internally by Scala Reflection, and is not recommended for use in client code.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Trees" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="TreesextendsAnyRef" class="anchorToMember"></a><a id="Trees:Trees" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Trees.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Trees.html" title="EXPERIMENTAL"><span class="name">Trees</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p>This trait defines the node types used in Scala abstract syntax trees (AST) and operations on them.</p><p>Trees are the basis for Scala's abstract syntax that is used to represent programs. They are also called
abstract syntax trees and commonly abbreviated as ASTs.</p><p>In Scala reflection, APIs that produce or use <code>Tree</code>s are:</p><ul><li><b>Annotations</b> which use trees to represent their arguments, exposed in <a href="Annotations$AnnotationApi.html#scalaArgs:List[Annotations.this.Tree]" name="scala.reflect.api.Annotations.AnnotationApi#scalaArgs" id="scala.reflect.api.Annotations.AnnotationApi#scalaArgs" class="extmbr">Annotation.scalaArgs</a>.</li><li><b><a href="Universe.html#reify[T](expr:T):Universe.this.Expr[T]" name="scala.reflect.api.Universe#reify" id="scala.reflect.api.Universe#reify" class="extmbr">reify</a></b>, a special method on <a href="Universe.html" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a> that takes an expression and returns an AST which represents the expression.</li><li><b>Macros and runtime compilation with toolboxes</b> which both use trees as their program representation medium.</li></ul><p> Trees are immutable, except for three fields
 <a href="Trees$TreeApi.html#pos:Trees.this.Position" name="scala.reflect.api.Trees.TreeApi#pos" id="scala.reflect.api.Trees.TreeApi#pos" class="extmbr">pos</a>, <a href="Trees$TreeApi.html#symbol:Trees.this.Symbol" name="scala.reflect.api.Trees.TreeApi#symbol" id="scala.reflect.api.Trees.TreeApi#symbol" class="extmbr">symbol</a>, and <a href="Trees$TreeApi.html#tpe:Trees.this.Type" name="scala.reflect.api.Trees.TreeApi#tpe" id="scala.reflect.api.Trees.TreeApi#tpe" class="extmbr">tpe</a>, which are assigned when a tree is typechecked
 to attribute it with the information gathered by the typechecker.</p><h5> Examples </h5><p> The following creates an AST representing a literal 5 in Scala source code:</p><pre>Literal(Constant(<span class="num">5</span>))</pre><p> The following creates an AST representing <code>print("Hello World")</code>:</p><pre>Apply(Select(Select(This(TypeName(<span class="lit">"scala"</span>)), TermName(<span class="lit">"Predef"</span>)), TermName(<span class="lit">"print"</span>)), <span class="std">List</span>(Literal(Constant(<span class="lit">"Hello World"</span>))))</pre><p> The following creates an AST from a literal 5, and then uses <code>showRaw</code> to print it in a readable format.</p><pre><span class="kw">import</span> scala.reflect.runtime.universe.{ reify, showRaw }
print( showRaw( reify{<span class="num">5</span>}.tree ) )` <span class="cmt">// prints Literal(Constant(5))</span></pre><p> For more information about <code>Tree</code>s, see the <a href="https://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" target="_blank">Reflection Guide: Symbols, Trees, Types</a>.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.TypeCreator" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="TypeCreatorextendsSerializable" class="anchorToMember"></a><a id="TypeCreator:TypeCreator" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/TypeCreator.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="TypeCreator.html" title="A mirror-aware factory for types."><span class="name">TypeCreator</span></a><span class="result"> extends <a href="../../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span><p class="shortcomment cmt">A mirror-aware factory for types.</p><div class="fullcomment"><div class="comment cmt"><p>A mirror-aware factory for types.</p><p>This class is used internally by Scala Reflection, and is not recommended for use in client code.
</p></div></div></li><li class="indented0 " name="scala.reflect.api.TypeTags" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="TypeTagsextendsAnyRef" class="anchorToMember"></a><a id="TypeTags:TypeTags" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/TypeTags.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TypeTags.html" title="A TypeTag[T] encapsulates the runtime type representation of some type T."><span class="name">TypeTags</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt">A <code>TypeTag[T]</code> encapsulates the runtime type representation of some type <code>T</code>.</p><div class="fullcomment"><div class="comment cmt"><p>A <code>TypeTag[T]</code> encapsulates the runtime type representation of some type <code>T</code>.
Like <a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/Manifest.html" name="scala.reflect.Manifest" id="scala.reflect.Manifest" class="extype">scala.reflect.Manifest</a>, the prime use case of <code>TypeTag</code>s is to give access
to erased types. However, <code>TypeTag</code>s should be considered to be a richer
replacement of the pre-2.10 notion of a <a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/Manifest.html" name="scala.reflect.Manifest" id="scala.reflect.Manifest" class="extype">Manifest</a>, that
are, in addition, fully integrated with Scala reflection.</p><p>There exist three different types of <code>TypeTags</code>:</p><ul><li><a href="TypeTags$TypeTag.html" name="scala.reflect.api.TypeTags.TypeTag" id="scala.reflect.api.TypeTags.TypeTag" class="extype">scala.reflect.api.TypeTags#TypeTag</a>. <br/>A full type descriptor of a Scala type.
 For example, a <code>TypeTag[List[String]]</code> contains all type information,
 in this case, of type <code>scala.List[String]</code>.</li><li><a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/ClassTag.html" name="scala.reflect.ClassTag" id="scala.reflect.ClassTag" class="extype">scala.reflect.ClassTag</a>. <br/>A partial type descriptor of a Scala type. For
 example, a <code>ClassTag[List[String]]</code> contains only the erased class
 type information, in this case, of type <code>scala.collection.immutable.List</code>.
 <code>ClassTag</code>s provide access only to the runtime class of a type.
 Analogous to <a href="../index.html#ClassManifest[T]=scala.reflect.ClassTag[T]" name="scala.reflect.ClassManifest" id="scala.reflect.ClassManifest" class="extmbr">scala.reflect.ClassManifest</a></li><li><a href="TypeTags$WeakTypeTag.html" name="scala.reflect.api.TypeTags.WeakTypeTag" id="scala.reflect.api.TypeTags.WeakTypeTag" class="extype">scala.reflect.api.TypeTags#WeakTypeTag</a>. <br/>A type descriptor for abstract
 types (see description below).</li></ul><p>Like <a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/Manifest.html" name="scala.reflect.Manifest" id="scala.reflect.Manifest" class="extype">Manifest</a>s, <code>TypeTag</code>s are always generated by the
compiler, and can be obtained in three ways:</p><h5> #1 Via the methods <a href="TypeTags.html#typeTag[T](implicitttag:TypeTags.this.TypeTag[T]):TypeTags.this.TypeTag[T]" name="scala.reflect.api.TypeTags#typeTag" id="scala.reflect.api.TypeTags#typeTag" class="extmbr">typeTag</a>,
<a href="../index.html#classTag[T](implicitctag:scala.reflect.ClassTag[T]):scala.reflect.ClassTag[T]" name="scala.reflect#classTag" id="scala.reflect#classTag" class="extmbr">classTag</a>, or <a href="TypeTags.html#weakTypeTag[T](implicitattag:TypeTags.this.WeakTypeTag[T]):TypeTags.this.WeakTypeTag[T]" name="scala.reflect.api.TypeTags#weakTypeTag" id="scala.reflect.api.TypeTags#weakTypeTag" class="extmbr">weakTypeTag</a> </h5><p>For example:</p><pre><span class="kw">import</span> scala.reflect.runtime.universe._
<span class="kw">val</span> tt = typeTag[<span class="std">Int</span>]

<span class="kw">import</span> scala.reflect._
<span class="kw">val</span> ct = classTag[<span class="std">String</span>]</pre><p>Each of these methods constructs a <code>TypeTag[T]</code> or <code>ClassTag[T]</code> for the given
type argument <code>T</code>.</p><h5> #2 Using an implicit parameter of type <code>TypeTag[T]</code>, <code>ClassTag[T]</code>, or <code>WeakTypeTag[T]</code> </h5><p>For example:</p><pre><span class="kw">import</span> scala.reflect.runtime.universe._

<span class="kw">def</span> paramInfo[T](x: T)(<span class="kw">implicit</span> tag: <span class="std">TypeTag</span>[T]): <span class="std">Unit</span> = {
  <span class="kw">val</span> targs = tag.tpe <span class="kw">match</span> { <span class="kw">case</span> TypeRef(_, _, args) <span class="kw">=&gt;</span> args }
  println(s<span class="lit">"type of $x has type arguments $targs"</span>)
}

scala&gt; paramInfo(<span class="num">42</span>)
<span class="kw">type</span> of <span class="num">42</span> has <span class="kw">type</span> arguments <span class="std">List</span>()

scala&gt; paramInfo(<span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>))
<span class="kw">type</span> of <span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>) has <span class="kw">type</span> arguments <span class="std">List</span>(<span class="std">Int</span>)</pre><h5> #3 Context bound of a type parameter </h5><p>...on methods or classes. The above example can be implemented as follows:</p><pre><span class="kw">import</span> scala.reflect.runtime.universe._

<span class="kw">def</span> paramInfo[T: <span class="std">TypeTag</span>](x: T): <span class="std">Unit</span> = {
  <span class="kw">val</span> targs = typeOf[T] <span class="kw">match</span> { <span class="kw">case</span> TypeRef(_, _, args) <span class="kw">=&gt;</span> args }
  println(s<span class="lit">"type of $x has type arguments $targs"</span>)
}

scala&gt; paramInfo(<span class="num">42</span>)
<span class="kw">type</span> of <span class="num">42</span> has <span class="kw">type</span> arguments <span class="std">List</span>()

scala&gt; paramInfo(<span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>))
<span class="kw">type</span> of <span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>) has <span class="kw">type</span> arguments <span class="std">List</span>(<span class="std">Int</span>)</pre><h5> <code>WeakTypeTag</code>s </h5><p><code>WeakTypeTag[T]</code> generalizes <code>TypeTag[T]</code>. Unlike a regular <code>TypeTag</code>, components of
its type representation can be references to type parameters or abstract types.
However, <code>WeakTypeTag[T]</code> tries to be as concrete as possible, i.e. if type tags
are available for the referenced type arguments or abstract types, they are used to
embed the concrete types into the <code>WeakTypeTag[T]</code>.</p><p>Continuing the example above:</p><pre><span class="kw">def</span> weakParamInfo[T](x: T)(<span class="kw">implicit</span> tag: <span class="std">WeakTypeTag</span>[T]): <span class="std">Unit</span> = {
  <span class="kw">val</span> targs = tag.tpe <span class="kw">match</span> { <span class="kw">case</span> TypeRef(_, _, args) <span class="kw">=&gt;</span> args }
  println(s<span class="lit">"type of $x has type arguments $targs"</span>)
}

scala&gt; <span class="kw">def</span> foo[T] = weakParamInfo(<span class="std">List</span>[T]())
foo: [T]<span class="kw">=&gt;</span> <span class="std">Unit</span>

scala&gt; foo[<span class="std">Int</span>]
<span class="kw">type</span> of <span class="std">List</span>() has <span class="kw">type</span> arguments <span class="std">List</span>(T)</pre><h5> TypeTags and Manifests </h5><p><code>TypeTag</code>s correspond loosely to the pre-2.10 notion of
<a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/Manifest.html" name="scala.reflect.Manifest" id="scala.reflect.Manifest" class="extype">scala.reflect.Manifest</a>s. While <a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/ClassTag.html" name="scala.reflect.ClassTag" id="scala.reflect.ClassTag" class="extype">scala.reflect.ClassTag</a> corresponds to
<a href="../index.html#ClassManifest[T]=scala.reflect.ClassTag[T]" name="scala.reflect.ClassManifest" id="scala.reflect.ClassManifest" class="extmbr">scala.reflect.ClassManifest</a> and <a href="TypeTags$TypeTag.html" name="scala.reflect.api.TypeTags.TypeTag" id="scala.reflect.api.TypeTags.TypeTag" class="extype">scala.reflect.api.TypeTags#TypeTag</a> mostly
corresponds to <a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/Manifest.html" name="scala.reflect.Manifest" id="scala.reflect.Manifest" class="extype">scala.reflect.Manifest</a>, other pre-2.10 <code>Manifest</code> types do not
have a direct correspondence with a 2.10 "<code>Tag</code>" type.</p><ul><li><b><a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/OptManifest.html" name="scala.reflect.OptManifest" id="scala.reflect.OptManifest" class="extype">scala.reflect.OptManifest</a> is not supported.</b> <br/>This is because <code>Tag</code>s
can reify arbitrary types, so they are always available.
 -</li><li><b>There is no equivalent for <a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/AnyValManifest.html" name="scala.reflect.AnyValManifest" id="scala.reflect.AnyValManifest" class="extype">scala.reflect.AnyValManifest</a>.</b> <br/>Instead, one
can compare their <code>Tag</code> with one of the base <code>Tag</code>s (defined in the corresponding
companion objects) in order to find out whether or not it represents a primitive
value class. Additionally, it's possible to simply use
<code>&lt;tag&gt;.tpe.typeSymbol.isPrimitiveValueClass</code>.</li><li><b>There are no replacement for factory methods defined in the <code>Manifest</code>
companion objects</b>. <br/>Instead, one could generate corresponding types using the
reflection APIs provided by Java (for classes) and Scala (for types).</li><li><b>Certain manifest operations(i.e., &lt;:&lt;, &gt;:&gt; and typeArguments) are not
supported.</b> <br/>Instead, one could use the reflection APIs provided by Java (for
classes) and Scala (for types).</li></ul><p>In Scala 2.10, <a href="../index.html#ClassManifest[T]=scala.reflect.ClassTag[T]" name="scala.reflect.ClassManifest" id="scala.reflect.ClassManifest" class="extmbr">scala.reflect.ClassManifest</a>s are deprecated, and it is planned
to deprecate <a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/Manifest.html" name="scala.reflect.Manifest" id="scala.reflect.Manifest" class="extype">scala.reflect.Manifest</a> in favor of <code>TypeTag</code>s and <code>ClassTag</code>s in
an upcoming point release. Thus, it is advisable to migrate any <code>Manifest</code>-based
APIs to use <code>Tag</code>s.</p><p>For more information about <code>TypeTag</code>s, see the
<a href="https://docs.scala-lang.org/overviews/reflection/typetags-manifests.html" target="_blank">Reflection Guide: TypeTags</a>
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/ClassTag.html" name="scala.reflect.ClassTag" id="scala.reflect.ClassTag" class="extype">scala.reflect.ClassTag</a>, <a href="TypeTags$TypeTag.html" name="scala.reflect.api.TypeTags.TypeTag" id="scala.reflect.api.TypeTags.TypeTag" class="extype">scala.reflect.api.TypeTags#TypeTag</a>, <a href="TypeTags$WeakTypeTag.html" name="scala.reflect.api.TypeTags.WeakTypeTag" id="scala.reflect.api.TypeTags.WeakTypeTag" class="extype">scala.reflect.api.TypeTags#WeakTypeTag</a></p></span></dd></dl></div></li><li class="indented0 " name="scala.reflect.api.Types" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="TypesextendsAnyRef" class="anchorToMember"></a><a id="Types:Types" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Types.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Types.html" title="EXPERIMENTAL"><span class="name">Types</span></a><span class="result"> extends <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt"> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p> <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p> A trait that defines types and operations on them.</p><p> Type instances represent information about the type of a corresponding symbol. This includes its members
 (methods, fields, type parameters, nested classes, traits, etc.) either declared directly or inherited, its base types,
 its erasure and so on. Types also provide operations to test for type conformance or equivalence or for widening.</p><p> To instantiate a type, most of the time, the <a href="TypeTags.html#typeOf[T](implicitttag:TypeTags.this.TypeTag[T]):TypeTags.this.Type" name="scala.reflect.api.TypeTags#typeOf" id="scala.reflect.api.TypeTags#typeOf" class="extmbr">scala.reflect.api.TypeTags#typeOf</a> method can be used. It takes
 a type argument and produces a <code>Type</code> instance which represents that argument. For example:</p><pre>scala&gt; typeOf[<span class="std">List</span>[<span class="std">Int</span>]]
res0: reflect.runtime.universe.Type = scala.<span class="std">List</span>[<span class="std">Int</span>]</pre><p> In this example, a <a href="Types$TypeRef.html" name="scala.reflect.api.Types.TypeRef" id="scala.reflect.api.Types.TypeRef" class="extype">scala.reflect.api.Types#TypeRef</a> is returned, which corresponds to the type constructor <code>List</code>
 applied to the type argument <code>Int</code>.</p><p> In the case of a generic type, you can also combine it with other types
 using <a href="Types.html#appliedType(sym:Types.this.Symbol,args:Types.this.Type*):Types.this.Type" name="scala.reflect.api.Types#appliedType" id="scala.reflect.api.Types#appliedType" class="extmbr">scala.reflect.api.Types#appliedType</a>. For example:</p><pre>scala&gt; <span class="kw">val</span> intType = typeOf[<span class="std">Int</span>]
intType: reflect.runtime.universe.Type = <span class="std">Int</span>

scala&gt; <span class="kw">val</span> listType = typeOf[<span class="std">List</span>[_]]
listType: reflect.runtime.universe.Type = <span class="std">List</span>[_]

scala&gt; appliedType(listType.typeConstructor, intType)
res0: reflect.runtime.universe.Type = <span class="std">List</span>[<span class="std">Int</span>]</pre><p> <i>Note:</i> Method <code>typeOf</code> does not work for types with type parameters, such as <code>typeOf[List[A]]</code> where <code>A</code> is
 a type parameter. In this case, use <a href="TypeTags.html#weakTypeOf[T](implicitattag:TypeTags.this.WeakTypeTag[T]):TypeTags.this.Type" name="scala.reflect.api.TypeTags#weakTypeOf" id="scala.reflect.api.TypeTags#weakTypeOf" class="extmbr">scala.reflect.api.TypeTags#weakTypeOf</a> instead.</p><p> For other ways to instantiate types, see the <a href="https://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" target="_blank">corresponding section of the Reflection Guide</a>.</p><h5> Common Operations on Types </h5><p> Types are typically used for type conformance tests or are queried for declarations of members or inner types.</p><ul><li><b>Subtyping Relationships</b> can be tested using <code>&lt;:&lt;</code> and <code>weak_&lt;:&lt;</code>.</li><li><b>Type Equality</b> can be checked with <code>=:=</code>. It's important to note that <code>==</code> should not be used to compare types for equality-- <code>==</code> can't check for type equality in the presence of type aliases, while <code>=:=</code> can.</li></ul><p> Types can be queried for members and declarations by using the <code>members</code> and <code>declarations</code> methods (along with
 their singular counterparts <code>member</code> and <code>declaration</code>), which provide the list of definitions associated with that type.
 For example, to look up the <code>map</code> method of <code>List</code>, one can do:</p><pre>scala&gt; typeOf[<span class="std">List</span>[_]].member(TermName(<span class="lit">"map"</span>))
res1: reflect.runtime.universe.<span class="std">Symbol</span> = method map</pre><p>For more information about <code>Type</code>s, see the <a href="https://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html" target="_blank">Reflection Guide: Symbols, Trees, and Types</a>
</p></div></div></li><li class="indented0 " name="scala.reflect.api.Universe" group="ReflectionAPI" fullComment="yes" data-isabs="true" visbl="pub"><a id="UniverseextendsSymbolswithTypeswithFlagSetswithScopeswithNameswithTreeswithConstantswithAnnotationswithPositionswithExprswithTypeTagswithImplicitTagswithStandardDefinitionswithStandardNameswithStandardLiftableswithMirrorswithPrinterswithLiftableswithQuasiquoteswithInternals" class="anchorToMember"></a><a id="Universe:Universe" class="anchorToMember"></a> <span class="permalink"><a href="../../../scala/reflect/api/Universe.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="Universe.html" title="EXPERIMENTAL"><span class="name">Universe</span></a><span class="result"> extends <a href="Symbols.html" name="scala.reflect.api.Symbols" id="scala.reflect.api.Symbols" class="extype">Symbols</a> with <a href="Types.html" name="scala.reflect.api.Types" id="scala.reflect.api.Types" class="extype">Types</a> with <a href="FlagSets.html" name="scala.reflect.api.FlagSets" id="scala.reflect.api.FlagSets" class="extype">FlagSets</a> with <a href="Scopes.html" name="scala.reflect.api.Scopes" id="scala.reflect.api.Scopes" class="extype">Scopes</a> with <a href="Names.html" name="scala.reflect.api.Names" id="scala.reflect.api.Names" class="extype">Names</a> with <a href="Trees.html" name="scala.reflect.api.Trees" id="scala.reflect.api.Trees" class="extype">Trees</a> with <a href="Constants.html" name="scala.reflect.api.Constants" id="scala.reflect.api.Constants" class="extype">Constants</a> with <a href="Annotations.html" name="scala.reflect.api.Annotations" id="scala.reflect.api.Annotations" class="extype">Annotations</a> with <a href="Positions.html" name="scala.reflect.api.Positions" id="scala.reflect.api.Positions" class="extype">Positions</a> with <a href="Exprs.html" name="scala.reflect.api.Exprs" id="scala.reflect.api.Exprs" class="extype">Exprs</a> with <a href="TypeTags.html" name="scala.reflect.api.TypeTags" id="scala.reflect.api.TypeTags" class="extype">TypeTags</a> with <a href="ImplicitTags.html" name="scala.reflect.api.ImplicitTags" id="scala.reflect.api.ImplicitTags" class="extype">ImplicitTags</a> with <a href="StandardDefinitions.html" name="scala.reflect.api.StandardDefinitions" id="scala.reflect.api.StandardDefinitions" class="extype">StandardDefinitions</a> with <a href="StandardNames.html" name="scala.reflect.api.StandardNames" id="scala.reflect.api.StandardNames" class="extype">StandardNames</a> with <a href="StandardLiftables.html" name="scala.reflect.api.StandardLiftables" id="scala.reflect.api.StandardLiftables" class="extype">StandardLiftables</a> with <a href="Mirrors.html" name="scala.reflect.api.Mirrors" id="scala.reflect.api.Mirrors" class="extype">Mirrors</a> with <a href="Printers.html" name="scala.reflect.api.Printers" id="scala.reflect.api.Printers" class="extype">Printers</a> with <a href="Liftables.html" name="scala.reflect.api.Liftables" id="scala.reflect.api.Liftables" class="extype">Liftables</a> with <a href="Quasiquotes.html" name="scala.reflect.api.Quasiquotes" id="scala.reflect.api.Quasiquotes" class="extype">Quasiquotes</a> with <a href="Internals.html" name="scala.reflect.api.Internals" id="scala.reflect.api.Internals" class="extype">Internals</a></span></span><p class="shortcomment cmt"><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><div class="fullcomment"><div class="comment cmt"><p><span class="badge badge-red" style="float: right;">EXPERIMENTAL</span></p><p><code>Universe</code> provides a complete set of reflection operations which make it possible for one
to reflectively inspect Scala type relations, such as membership or subtyping.</p><p><a href="Universe.html" name="scala.reflect.api.Universe" id="scala.reflect.api.Universe" class="extype">scala.reflect.api.Universe</a> has two specialized sub-universes for different scenarios.
<a href="JavaUniverse.html" name="scala.reflect.api.JavaUniverse" id="scala.reflect.api.JavaUniverse" class="extype">scala.reflect.api.JavaUniverse</a> adds operations that link symbols and types to the underlying
classes and runtime values of a JVM instance-- this can be thought of as the <code>Universe</code> that
should be used for all typical use-cases of Scala reflection. <a href="../macros/Universe.html" name="scala.reflect.macros.Universe" id="scala.reflect.macros.Universe" class="extype">scala.reflect.macros.Universe</a>
adds operations which allow macros to access selected compiler data structures and operations--
this type of <code>Universe</code> should only ever exist within the implementation of a Scala macro.</p><p><code>Universe</code> can be thought of as the entry point to Scala reflection. It mixes-in, and thus provides
an interface to the following main types:</p><ul><li><a href="Types$Type.html" name="scala.reflect.api.Types.Type" id="scala.reflect.api.Types.Type" class="extype">Types</a> represent types</li><li><a href="Symbols$Symbol.html" name="scala.reflect.api.Symbols.Symbol" id="scala.reflect.api.Symbols.Symbol" class="extype">Symbols</a> represent definitions</li><li><a href="Trees$Tree.html" name="scala.reflect.api.Trees.Tree" id="scala.reflect.api.Trees.Tree" class="extype">Trees</a> represent abstract syntax trees</li><li><a href="Names.html#Name&gt;:Null&lt;:Names.this.NameApi" name="scala.reflect.api.Names.Name" id="scala.reflect.api.Names.Name" class="extmbr">Names</a> represent term and type names</li><li><a href="Annotations$Annotation.html" name="scala.reflect.api.Annotations.Annotation" id="scala.reflect.api.Annotations.Annotation" class="extype">Annotations</a> represent annotations</li><li><a href="Positions.html#Position&gt;:Null&lt;:scala.reflect.api.Position{typePos=Positions.this.Position}" name="scala.reflect.api.Positions.Position" id="scala.reflect.api.Positions.Position" class="extmbr">Positions</a> represent source positions of tree nodes</li><li><a href="FlagSets$FlagSet.html" name="scala.reflect.api.FlagSets.FlagSet" id="scala.reflect.api.FlagSets.FlagSet" class="extype">FlagSet</a> represent sets of flags that apply to symbols and
    definition trees</li><li><a href="Constants.html#Constant&gt;:Null&lt;:Constants.this.ConstantApi" name="scala.reflect.api.Constants.Constant" id="scala.reflect.api.Constants.Constant" class="extmbr">Constants</a> represent compile-time constants.</li></ul><p>To obtain a <code>Universe</code> to use with Scala runtime reflection, simply make sure to use or import
<code>scala.reflect.runtime.universe._</code></p><pre>scala&gt; <span class="kw">import</span> scala.reflect.runtime.universe._
<span class="kw">import</span> scala.reflect.runtime.universe._

scala&gt; typeOf[<span class="std">List</span>[<span class="std">Int</span>]]
res0: reflect.runtime.universe.Type = scala.<span class="std">List</span>[<span class="std">Int</span>]

scala&gt; typeOf[Either[<span class="std">String</span>, <span class="std">Int</span>]]
res1: reflect.runtime.universe.Type = scala.Either[<span class="std">String</span>,<span class="std">Int</span>]</pre><p>To obtain a <code>Universe</code> for use within a Scala macro, use <a href="../macros/blackbox/Context.html#universe:scala.reflect.macros.Universe" name="scala.reflect.macros.blackbox.Context#universe" id="scala.reflect.macros.blackbox.Context#universe" class="extmbr">scala.reflect.macros.blackbox.Context#universe</a>.
or <a href="../macros/whitebox/Context.html#universe:scala.reflect.macros.Universe" name="scala.reflect.macros.whitebox.Context#universe" id="scala.reflect.macros.whitebox.Context#universe" class="extmbr">scala.reflect.macros.whitebox.Context#universe</a>. For example:</p><pre><span class="kw">def</span> printf(format: <span class="std">String</span>, params: <span class="std">Any</span>*): <span class="std">Unit</span> = macro impl
<span class="kw">def</span> impl(c: Context)(format: c.Expr[<span class="std">String</span>], params: c.Expr[Any]*): c.Expr[<span class="std">Unit</span>] = {
  <span class="kw">import</span> c.universe._
  ...
}</pre><p>For more information about <code>Universe</code>s, see the <a href="https://docs.scala-lang.org/overviews/reflection/environment-universes-mirrors.html" target="_blank">Reflection Guide: Universes</a>
</p></div></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.12/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="ReflectionAPI" class="group"><h3>Scala Reflection API</h3></div><div name="Tags" class="group"><h3>Tags</h3><div class="comment cmt"><p>Implicit values that provide <a href="https://www.scala-lang.org/api/2.13.12/scala/reflect/ClassTag.html" name="scala.reflect.ClassTag" id="scala.reflect.ClassTag" class="extype"><code>ClassTags</code></a> for the reflection
                       classes. These are abstract in the interface but are later filled in to provide ClassTags
                       for the either the runtime reflection or macros entities, depending on the use.</p></div></div><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer">Scala programming documentation. Copyright (c) 2002-2023 <a href="https://www.epfl.ch" target="_top">EPFL</a> and <a href="https://www.lightbend.com" target="_top">Lightbend</a>.</div></body></div></div></div></body></html>
