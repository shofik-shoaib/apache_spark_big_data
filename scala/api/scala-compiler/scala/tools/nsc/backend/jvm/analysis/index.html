<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Scala Compiler 2.13.12 - scala.tools.nsc.backend.jvm.analysis</title><meta content="Scala Compiler 2.13.12 - scala.tools.nsc.backend.jvm.analysis" name="description"/><meta content="Scala Compiler 2.13.12 scala.tools.nsc.backend.jvm.analysis" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../../../../lib/index.js"></script><script type="text/javascript" src="../../../../../../index.js"></script><script type="text/javascript" src="../../../../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../../../../lib/template.js"></script><script type="text/javascript" src="https://d3js.org/d3.v4.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../../../../';</script></head><body><div id="search"><span id="doc-title">Scala Compiler<span id="doc-version">2.13.12</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../../../../index.html" title="The Scala compiler and reflection APIs."><span class="name">root</span></a></span><p class="shortcomment cmt">The Scala compiler and reflection APIs.</p><div class="fullcomment"><div class="comment cmt"><p>The Scala compiler and reflection APIs.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.scala" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scala" class="anchorToMember"></a><a id="scala:scala" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../../../index.html" title=""><span class="name">scala</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="scala.tools" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tools" class="anchorToMember"></a><a id="tools:tools" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../../index.html" title=""><span class="name">tools</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../../index.html" name="scala" id="scala" class="extype">scala</a></dd></dl></div></li><li class="indented3 " name="scala.tools.nsc" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="nsc" class="anchorToMember"></a><a id="nsc:nsc" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">nsc</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../index.html" name="scala.tools" id="scala.tools" class="extype">tools</a></dd></dl></div></li><li class="indented4 " name="scala.tools.nsc.backend" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="backend" class="anchorToMember"></a><a id="backend:backend" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">backend</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="scala.tools.nsc" id="scala.tools.nsc" class="extype">nsc</a></dd></dl></div></li><li class="indented5 " name="scala.tools.nsc.backend.jvm" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="jvm" class="anchorToMember"></a><a id="jvm:jvm" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">jvm</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="scala.tools.nsc.backend" id="scala.tools.nsc.backend" class="extype">backend</a></dd></dl></div></li><li class="indented6 current" name="scala.tools.nsc.backend.jvm.analysis" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="analysis" class="anchorToMember"></a><a id="analysis:analysis" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">analysis</span></span><p class="shortcomment cmt">Summary on the ASM analyzer framework
--------------------------------------</p><div class="fullcomment"><div class="comment cmt"><p>Summary on the ASM analyzer framework
--------------------------------------</p><p>Value</p><ul><li>Abstract, needs to be implemented for each analysis.</li><li>Represents the desired information about local variables and stack values, for example:<ul><li>Is this value known to be null / not null?</li><li>What are the instructions that could potentially have produced this value?</li></ul></li></ul><p>Interpreter</p><ul><li>Abstract, needs to be implemented for each analysis. Sometimes one can subclass an existing
   interpreter, e.g., SourceInterpreter or BasicInterpreter.</li><li>Multiple abstract methods that receive an instruction and the instruction's input values, and
   return a value representing the result of that instruction.<ul><li>Note: due to control flow, the interpreter can be invoked multiple times for the same
     instruction, until reaching a fixed point.</li></ul></li><li>Abstract <code>merge</code> function that computes the least upper bound of two values. Used by
   Frame.merge (see below).</li></ul><p>Frame</p><ul><li>Can be used directly for many analyses, no subclass required.</li><li>Every frame has an array of values: one for each local variable and for each stack slot.<ul><li>A <code>top</code> index stores the index of the current stack top</li><li>NOTE: for a size-2 local variable at index i, the local variable at i+1 is set to an empty
     value. However, for a size-2 value at index i on the stack, the value at i+1 holds the next
     stack value. IMPORTANT: this is only the case in ASM's analysis framework, not in bytecode.
     See comment below.</li></ul></li><li>Defines the <code>execute(instruction)</code> method.<ul><li>executing mutates the state of the frame according to the effect of the instruction<ul><li>pop consumed values from the stack</li><li>pass them to the interpreter together with the instruction</li><li>if applicable, push the resulting value on the stack</li></ul></li></ul></li><li>Defines the <code>merge(otherFrame)</code> method<ul><li>called by the analyzer when multiple control flow paths lead to an instruction<ul><li>the frame at the branching instruction is merged into the current frame of the
       instruction (held by the analyzer)</li><li>mutates the values of the current frame, merges all values using interpreter.merge.</li></ul></li></ul></li></ul><p>Analyzer</p><ul><li>Stores a frame for each instruction</li><li><code>merge</code> function takes an instruction and a frame, merges the existing frame for that instr
    (from the frames array) with the new frame passed as argument.
    if the frame changed, puts the instruction on the work queue (fixpoint).</li><li>initial frame: initialized for first instr by calling interpreter.new[...]Value
    for each slot (locals and params), stored in frames[firstInstr] by calling <code>merge</code></li><li>work queue of instructions (<code>queue</code> array, <code>top</code> index for next instruction to analyze)</li><li>analyze(method): simulate control flow. while work queue non-empty:<ul><li>copy the state of <code>frames[instr]</code> into a local frame <code>current</code></li><li>call <code>current.execute(instr, interpreter)</code>, mutating the <code>current</code> frame</li><li>if it's a branching instruction<ul><li>for all potential destination instructions<ul><li>merge the destination instruction frame with the <code>current</code> frame
          (this enqueues the destination instr if its frame changed)</li></ul></li><li>invoke <code>newControlFlowEdge</code> (see below)</li></ul></li></ul></li><li>the analyzer also tracks active exception handlers at each instruction</li><li>the empty method <code>newControlFlowEdge</code> can be overridden to track control flow if required</li></ul><p>MaxLocals and MaxStack
----------------------</p><p>At the JVM level, long and double values occupy two slots, both as local variables and on the
stack, as specified in the JVM spec 2.6.2:
  "At any point in time, an operand stack has an associated depth, where a value of type long or
   double contributes two units to the depth and a value of any other type contributes one unit."</p><p>For example, a method
  class A { def f(a: Long, b: Long) = a + b }
has MAXSTACK=4 in the classfile. This value is computed by the ClassWriter / MethodWriter when
generating the classfile (we always pass COMPUTE_MAXS to the ClassWriter).</p><p>For running an ASM Analyzer, long and double values occupy two local variable slots, but only
a single slot on the call stack, as shown by the following snippet:</p><p>  import scala.tools.nsc.backend.jvm._
  import scala.tools.nsc.backend.jvm.opt.BytecodeUtils._
  import scala.collection.convert.decorateAsScala._
  import scala.tools.asm.tree.analysis._</p><p>  val cn = AsmUtils.readClass("/Users/luc/scala/scala/sandbox/A.class")
  val m = cn.methods.iterator.asScala.find(_.name == "f").head</p><p>  // the value is read from the classfile, so it's 4
  println(s"maxLocals: ${m.maxLocals}, maxStack: ${m.maxStack}") // maxLocals: 5, maxStack: 4</p><p>  // we can safely set it to 2 for running the analyzer.
  m.maxStack = 2</p><p>  val a = new Analyzer(new BasicInterpreter)
  a.analyze(cn.name, m)
  val addInsn = m.instructions.iterator.asScala.find(_.getOpcode == 97).get // LADD Opcode
  val addFrame = a.frameAt(addInsn, m)</p><p>  addFrame.getStackSize // 2: the two long values only take one slot each
  addFrame.getLocals    // 5: this takes one slot, the two long parameters take 2 slots each</p><p>While running the optimizer, we need to make sure that the <code>maxStack</code> value of a method is
large enough for running an ASM analyzer. We don't need to worry if the value is incorrect in
the JVM perspective: the value will be re-computed and overwritten in the ClassWriter.</p><p>Lessons learnt while benchmarking the alias tracking analysis
-------------------------------------------------------------</p><p>Profiling</p><ul><li>Use YourKit for finding hotspots (cpu profiling). when it comes to drilling down into the details
   of a hotspot, don't pay too much attention to the percentages / time counts.</li><li>Should also try other profilers.</li><li>Use timers. When a method showed up as a hotspot, I added a timer around that method, and a
   second one within the method to measure specific parts. The timers slow things down, but the
   relative numbers show what parts of a method are slow.</li></ul><p>ASM analyzer insights</p><ul><li>The time for running an analysis depends on the number of locals and the number of instructions.
   Reducing the number of locals helps speeding up the analysis: there are less values to
   merge when merging to frames.
   See also https://github.com/scala/scala-dev/issues/47</li><li>The common hot spot of an ASM analysis is Frame.merge, for example in producers / consumers.</li><li>For nullness analysis the time is spent as follows<ul><li>20% merging nullness values. this is as expected: for example, the same absolute amount of
     time is spent in merging BasicValues when running a BasicInterpreter.</li><li>50% merging alias sets. i tried to optimize what i could out of this.</li><li>20% is spent creating new frames from existing ones, see comment on AliasingFrame.init.</li></ul></li><li>The implementation of Frame.merge (the main hot spot) contains a megamorphic callsite to
   <code>interpreter.merge</code>. This can be observed easily by running a test program that either runs
   a BasicValue analysis only, versus a program that first runs a nullness analysis and then
   a BasicValue. In an example, the time for the BasicValue analysis goes from 519ms to 1963ms,
   a 3.8x slowdown.</li><li>I added counters to the Frame.merge methods for nullness and BasicValue analysis. In the
   examples I benchmarked, the number of merge invocations was always exactly the same.
   It would probably be possible to come up with an example where alias set merging forces
   additional analysis rounds until reaching the fixpoint, but I did not observe such cases.</li></ul><p>To benchmark an analysis, instead of benchmarking analysis while it runs in the compiler
backend, one can easily run it from a separate program (or the repl). The bytecode to analyze
can simply be parsed from a classfile. See example at the end of this comment.</p><p>Nullness Analysis in Miguel's Optimizer
---------------------------------------</p><p>Miguel implemented alias tracking for nullness analysis differently [1]. Remember that every
frame has an array of values. Miguel's idea was to represent aliasing using reference equality
in the values array: if two entries in the array point to the same value object, the two entries
are aliases in the frame of the given instruction.</p><p>While this idea seems elegant at first sight, Miguel's implementation does not merge frames
correctly when it comes to aliasing. Assume in frame 1, values (a, b, c) are aliases, while in
frame 2 (a, b) are aliases. When merging the second into the first, we have to make sure that
c is removed as an alias of (a, b).</p><p>It would be possible to implement correct alias set merging in Miguel's approach. However, frame
merging is the main hot spot of analysis. The computational complexity of implementing alias set
merging by traversing the values array and comparing references is too high. The concrete
alias set representation that is used in the current implementation (see class AliasingFrame)
makes alias set merging more efficient.</p><p>[1] https://github.com/scala-opt/scala/blob/opt/rebase/src/compiler/scala/tools/nsc/backend/bcode/NullnessPropagator.java</p><p>Complexity and scaling of analysis
----------------------------------</p><p>The time complexity of a data flow analysis depends on:</p><ul><li>The size of the method. The complexity factor is linear (assuming the number of locals and
    branching instructions remains constant). The main analysis loop runs through all
    instructions of a method once. Instructions are only re-enqueued if a control flow merge
    changes the frame at some instruction.</li><li>The branching instructions. When a second (third, ..) control flow edge arrives at an
    instruction, the existing frame at the instruction is merged with the one computed on the
    new branch. If the merge function changes the existing frame, the instruction is enqueued
    for another analysis. This results in a merge operation for the successors of the
    instruction.</li><li>The number of local variables. The hot spot of analysis is frame merging. The merge function
    iterates through the values in the frame (locals and stack values) and merges them.</li></ul><p>I measured the running time of an analysis for two examples:</p><ul><li>Keep the number of locals and branching instructions constant, increase the number of
    instructions. The running time grows linearly with the method size.</li><li>Increase the size and number of locals in a method. The method size and number of locals
    grow in the same pace. Here, the running time increase is polynomial. It looks like the
    complexity is be #instructions * #locals^2 (see below).</li></ul><p>I measured nullness analysis (which tracks aliases) and a SimpleValue analysis. Nullness runs
roughly 5x slower (because of alias tracking) at every problem size - this factor doesn't change.</p><p>The numbers below are for nullness. Note that the last column is constant, i.e., the running
time is proportional to #ins * #loc^2. Therefore we use this factor when limiting the maximal
method size for running an analysis.</p><p>  #insns    #locals    time (ms)       time / #ins * #loc<sup>2 * 10</sup>6
  1305      156        34              1.07
  2610      311        165             0.65
  3915      466        490             0.57
  5220      621        1200            0.59
  6525      776        2220            0.56
  7830      931        3830            0.56
  9135      1086       6570            0.60
  10440     1241       9700            0.60
  11745     1396       13800           0.60</p><p>As a second experiment, nullness analysis was run with varying #insns but constant #locals.
The last column shows linear complexity with respect to the method size (linearOffset = 2279):</p><p>  #insns     #locals     time (ms)    (time + linearOffset) / #insns
  5220       621         1090         0.645
  6224       621         1690         0.637
  7226       621         2280         0.630
  8228       621         2870         0.625
  9230       621         3530         0.629
  10232      621         4130         0.626
  11234      621         4770         0.627
  12236      621         5520         0.637
  13238      621         6170         0.638</p><p>When running a BasicValue analysis, the complexity observation is the same (time is proportional
to #ins * #loc^2).</p><p>Measuring analysis execution time
---------------------------------</p><p>See code below.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="scala.tools.nsc.backend.jvm" id="scala.tools.nsc.backend.jvm" class="extype">jvm</a></dd></dl></div></li><li class="current-entities indented6"><a href="AliasSet$.html" title="" class="object"></a> <a href="AliasSet.html" title="An efficient mutable bit set." class="class"></a><a href="AliasSet.html" title="An efficient mutable bit set.">AliasSet</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="AliasingAnalyzer.html" title="An analyzer that uses AliasingFrames instead of bare Frames." class="class"></a><a href="AliasingAnalyzer.html" title="An analyzer that uses AliasingFrames instead of bare Frames.">AliasingAnalyzer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="AliasingAsmAnalyzerMarker.html" title="" class="trait"></a><a href="AliasingAsmAnalyzerMarker.html" title="">AliasingAsmAnalyzerMarker</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="AliasingFrame.html" title="A subclass of Frame that tracks aliasing of values stored in local variables and on the stack." class="class"></a><a href="AliasingFrame.html" title="A subclass of Frame that tracks aliasing of values stored in local variables and on the stack.">AliasingFrame</a></li><li class="current-entities indented6"><a href="AsmAnalyzer$.html" title="See the doc comment on package object analysis for a discussion on performance." class="object"></a> <a href="AsmAnalyzer.html" title="A wrapper to make ASM's Analyzer a bit easier to use." class="class"></a><a href="AsmAnalyzer.html" title="A wrapper to make ASM's Analyzer a bit easier to use.">AsmAnalyzer</a></li><li class="current-entities indented6"><a href="BackendUtils$.html" title="" class="object"></a> <a href="BackendUtils.html" title="This component hosts tools and utilities used in the backend that require access to a BTypes instance." class="class"></a><a href="BackendUtils.html" title="This component hosts tools and utilities used in the backend that require access to a BTypes instance.">BackendUtils</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="BasicAliasingAnalyzer.html" title="" class="class"></a><a href="BasicAliasingAnalyzer.html" title="">BasicAliasingAnalyzer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="BasicAnalyzer.html" title="" class="class"></a><a href="BasicAnalyzer.html" title="">BasicAnalyzer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="ExceptionProducer.html" title="" class="class"></a><a href="ExceptionProducer.html" title="">ExceptionProducer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="InitialProducer.html" title="A class for pseudo-instructions representing the initial producers of local values that have no producer instruction in the method:" class="class"></a><a href="InitialProducer.html" title="A class for pseudo-instructions representing the initial producers of local values that have no producer instruction in the method:">InitialProducer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="InitialProducerSourceInterpreter.html" title="" class="class"></a><a href="InitialProducerSourceInterpreter.html" title="">InitialProducerSourceInterpreter</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="InstructionStackEffect$.html" title="" class="object"></a><a href="InstructionStackEffect$.html" title="">InstructionStackEffect</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="IntIterator.html" title="An iterator over Int (required to prevent boxing the result of next)." class="class"></a><a href="IntIterator.html" title="An iterator over Int (required to prevent boxing the result of next).">IntIterator</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="NonLubbingTypeFlowAnalyzer.html" title="" class="class"></a><a href="NonLubbingTypeFlowAnalyzer.html" title="">NonLubbingTypeFlowAnalyzer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="NonLubbingTypeFlowInterpreter.html" title="A TypeFlowInterpreter which collapses LUBs of non-equal reference types to Object." class="class"></a><a href="NonLubbingTypeFlowInterpreter.html" title="A TypeFlowInterpreter which collapses LUBs of non-equal reference types to Object.">NonLubbingTypeFlowInterpreter</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="NotNullValue$.html" title="" class="object"></a><a href="NotNullValue$.html" title="">NotNullValue</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="NullValue$.html" title="" class="object"></a><a href="NullValue$.html" title="">NullValue</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="NullnessAnalyzer.html" title="" class="class"></a><a href="NullnessAnalyzer.html" title="">NullnessAnalyzer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="NullnessAnalyzerImpl.html" title="" class="class"></a><a href="NullnessAnalyzerImpl.html" title="">NullnessAnalyzerImpl</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="NullnessFrame.html" title="" class="class"></a><a href="NullnessFrame.html" title="">NullnessFrame</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="NullnessInterpreter.html" title="" class="class"></a><a href="NullnessInterpreter.html" title="">NullnessInterpreter</a></li><li class="current-entities indented6"><a href="NullnessValue$.html" title="" class="object"></a> <a href="NullnessValue.html" title="Represents the nullness state for a local variable or stack value." class="class"></a><a href="NullnessValue.html" title="Represents the nullness state for a local variable or stack value.">NullnessValue</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="ParameterProducer.html" title="" class="class"></a><a href="ParameterProducer.html" title="">ParameterProducer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="ProdConsAnalyzer.html" title="This class provides additional queries over ASM's built-in SourceValue analysis." class="class"></a><a href="ProdConsAnalyzer.html" title="This class provides additional queries over ASM's built-in SourceValue analysis.">ProdConsAnalyzer</a></li><li class="current-entities indented6"><a href="TypeFlowInterpreter$.html" title="" class="object"></a> <a href="TypeFlowInterpreter.html" title="" class="class"></a><a href="TypeFlowInterpreter.html" title="">TypeFlowInterpreter</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="UninitializedLocalProducer.html" title="" class="class"></a><a href="UninitializedLocalProducer.html" title="">UninitializedLocalProducer</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="UnknownValue1$.html" title="" class="object"></a><a href="UnknownValue1$.html" title="">UnknownValue1</a></li><li class="current-entities indented6"><span class="separator"></span> <a href="UnknownValue2$.html" title="" class="object"></a><a href="UnknownValue2$.html" title="">UnknownValue2</a></li><li class="indented6 " name="scala.tools.nsc.backend.jvm.opt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="opt" class="anchorToMember"></a><a id="opt:opt" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/opt/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../opt/index.html" title=""><span class="name">opt</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="scala.tools.nsc.backend.jvm" id="scala.tools.nsc.backend.jvm" class="extype">jvm</a></dd></dl></div></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../../../../../index.html" name="scala" id="scala" class="extype">scala</a>.<a href="../../../../index.html" name="scala.tools" id="scala.tools" class="extype">tools</a>.<a href="../../../index.html" name="scala.tools.nsc" id="scala.tools.nsc" class="extype">nsc</a>.<a href="../../index.html" name="scala.tools.nsc.backend" id="scala.tools.nsc.backend" class="extype">backend</a>.<a href="../index.html" name="scala.tools.nsc.backend.jvm" id="scala.tools.nsc.backend.jvm" class="extype">jvm</a></p><h1>analysis<span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">analysis</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Summary on the ASM analyzer framework
--------------------------------------</p><p>Value</p><ul><li>Abstract, needs to be implemented for each analysis.</li><li>Represents the desired information about local variables and stack values, for example:<ul><li>Is this value known to be null / not null?</li><li>What are the instructions that could potentially have produced this value?</li></ul></li></ul><p>Interpreter</p><ul><li>Abstract, needs to be implemented for each analysis. Sometimes one can subclass an existing
   interpreter, e.g., SourceInterpreter or BasicInterpreter.</li><li>Multiple abstract methods that receive an instruction and the instruction's input values, and
   return a value representing the result of that instruction.<ul><li>Note: due to control flow, the interpreter can be invoked multiple times for the same
     instruction, until reaching a fixed point.</li></ul></li><li>Abstract <code>merge</code> function that computes the least upper bound of two values. Used by
   Frame.merge (see below).</li></ul><p>Frame</p><ul><li>Can be used directly for many analyses, no subclass required.</li><li>Every frame has an array of values: one for each local variable and for each stack slot.<ul><li>A <code>top</code> index stores the index of the current stack top</li><li>NOTE: for a size-2 local variable at index i, the local variable at i+1 is set to an empty
     value. However, for a size-2 value at index i on the stack, the value at i+1 holds the next
     stack value. IMPORTANT: this is only the case in ASM's analysis framework, not in bytecode.
     See comment below.</li></ul></li><li>Defines the <code>execute(instruction)</code> method.<ul><li>executing mutates the state of the frame according to the effect of the instruction<ul><li>pop consumed values from the stack</li><li>pass them to the interpreter together with the instruction</li><li>if applicable, push the resulting value on the stack</li></ul></li></ul></li><li>Defines the <code>merge(otherFrame)</code> method<ul><li>called by the analyzer when multiple control flow paths lead to an instruction<ul><li>the frame at the branching instruction is merged into the current frame of the
       instruction (held by the analyzer)</li><li>mutates the values of the current frame, merges all values using interpreter.merge.</li></ul></li></ul></li></ul><p>Analyzer</p><ul><li>Stores a frame for each instruction</li><li><code>merge</code> function takes an instruction and a frame, merges the existing frame for that instr
    (from the frames array) with the new frame passed as argument.
    if the frame changed, puts the instruction on the work queue (fixpoint).</li><li>initial frame: initialized for first instr by calling interpreter.new[...]Value
    for each slot (locals and params), stored in frames[firstInstr] by calling <code>merge</code></li><li>work queue of instructions (<code>queue</code> array, <code>top</code> index for next instruction to analyze)</li><li>analyze(method): simulate control flow. while work queue non-empty:<ul><li>copy the state of <code>frames[instr]</code> into a local frame <code>current</code></li><li>call <code>current.execute(instr, interpreter)</code>, mutating the <code>current</code> frame</li><li>if it's a branching instruction<ul><li>for all potential destination instructions<ul><li>merge the destination instruction frame with the <code>current</code> frame
          (this enqueues the destination instr if its frame changed)</li></ul></li><li>invoke <code>newControlFlowEdge</code> (see below)</li></ul></li></ul></li><li>the analyzer also tracks active exception handlers at each instruction</li><li>the empty method <code>newControlFlowEdge</code> can be overridden to track control flow if required</li></ul><p>MaxLocals and MaxStack
----------------------</p><p>At the JVM level, long and double values occupy two slots, both as local variables and on the
stack, as specified in the JVM spec 2.6.2:
  "At any point in time, an operand stack has an associated depth, where a value of type long or
   double contributes two units to the depth and a value of any other type contributes one unit."</p><p>For example, a method
  class A { def f(a: Long, b: Long) = a + b }
has MAXSTACK=4 in the classfile. This value is computed by the ClassWriter / MethodWriter when
generating the classfile (we always pass COMPUTE_MAXS to the ClassWriter).</p><p>For running an ASM Analyzer, long and double values occupy two local variable slots, but only
a single slot on the call stack, as shown by the following snippet:</p><p>  import scala.tools.nsc.backend.jvm._
  import scala.tools.nsc.backend.jvm.opt.BytecodeUtils._
  import scala.collection.convert.decorateAsScala._
  import scala.tools.asm.tree.analysis._</p><p>  val cn = AsmUtils.readClass("/Users/luc/scala/scala/sandbox/A.class")
  val m = cn.methods.iterator.asScala.find(_.name == "f").head</p><p>  // the value is read from the classfile, so it's 4
  println(s"maxLocals: ${m.maxLocals}, maxStack: ${m.maxStack}") // maxLocals: 5, maxStack: 4</p><p>  // we can safely set it to 2 for running the analyzer.
  m.maxStack = 2</p><p>  val a = new Analyzer(new BasicInterpreter)
  a.analyze(cn.name, m)
  val addInsn = m.instructions.iterator.asScala.find(_.getOpcode == 97).get // LADD Opcode
  val addFrame = a.frameAt(addInsn, m)</p><p>  addFrame.getStackSize // 2: the two long values only take one slot each
  addFrame.getLocals    // 5: this takes one slot, the two long parameters take 2 slots each</p><p>While running the optimizer, we need to make sure that the <code>maxStack</code> value of a method is
large enough for running an ASM analyzer. We don't need to worry if the value is incorrect in
the JVM perspective: the value will be re-computed and overwritten in the ClassWriter.</p><p>Lessons learnt while benchmarking the alias tracking analysis
-------------------------------------------------------------</p><p>Profiling</p><ul><li>Use YourKit for finding hotspots (cpu profiling). when it comes to drilling down into the details
   of a hotspot, don't pay too much attention to the percentages / time counts.</li><li>Should also try other profilers.</li><li>Use timers. When a method showed up as a hotspot, I added a timer around that method, and a
   second one within the method to measure specific parts. The timers slow things down, but the
   relative numbers show what parts of a method are slow.</li></ul><p>ASM analyzer insights</p><ul><li>The time for running an analysis depends on the number of locals and the number of instructions.
   Reducing the number of locals helps speeding up the analysis: there are less values to
   merge when merging to frames.
   See also https://github.com/scala/scala-dev/issues/47</li><li>The common hot spot of an ASM analysis is Frame.merge, for example in producers / consumers.</li><li>For nullness analysis the time is spent as follows<ul><li>20% merging nullness values. this is as expected: for example, the same absolute amount of
     time is spent in merging BasicValues when running a BasicInterpreter.</li><li>50% merging alias sets. i tried to optimize what i could out of this.</li><li>20% is spent creating new frames from existing ones, see comment on AliasingFrame.init.</li></ul></li><li>The implementation of Frame.merge (the main hot spot) contains a megamorphic callsite to
   <code>interpreter.merge</code>. This can be observed easily by running a test program that either runs
   a BasicValue analysis only, versus a program that first runs a nullness analysis and then
   a BasicValue. In an example, the time for the BasicValue analysis goes from 519ms to 1963ms,
   a 3.8x slowdown.</li><li>I added counters to the Frame.merge methods for nullness and BasicValue analysis. In the
   examples I benchmarked, the number of merge invocations was always exactly the same.
   It would probably be possible to come up with an example where alias set merging forces
   additional analysis rounds until reaching the fixpoint, but I did not observe such cases.</li></ul><p>To benchmark an analysis, instead of benchmarking analysis while it runs in the compiler
backend, one can easily run it from a separate program (or the repl). The bytecode to analyze
can simply be parsed from a classfile. See example at the end of this comment.</p><p>Nullness Analysis in Miguel's Optimizer
---------------------------------------</p><p>Miguel implemented alias tracking for nullness analysis differently [1]. Remember that every
frame has an array of values. Miguel's idea was to represent aliasing using reference equality
in the values array: if two entries in the array point to the same value object, the two entries
are aliases in the frame of the given instruction.</p><p>While this idea seems elegant at first sight, Miguel's implementation does not merge frames
correctly when it comes to aliasing. Assume in frame 1, values (a, b, c) are aliases, while in
frame 2 (a, b) are aliases. When merging the second into the first, we have to make sure that
c is removed as an alias of (a, b).</p><p>It would be possible to implement correct alias set merging in Miguel's approach. However, frame
merging is the main hot spot of analysis. The computational complexity of implementing alias set
merging by traversing the values array and comparing references is too high. The concrete
alias set representation that is used in the current implementation (see class AliasingFrame)
makes alias set merging more efficient.</p><p>[1] https://github.com/scala-opt/scala/blob/opt/rebase/src/compiler/scala/tools/nsc/backend/bcode/NullnessPropagator.java</p><p>Complexity and scaling of analysis
----------------------------------</p><p>The time complexity of a data flow analysis depends on:</p><ul><li>The size of the method. The complexity factor is linear (assuming the number of locals and
    branching instructions remains constant). The main analysis loop runs through all
    instructions of a method once. Instructions are only re-enqueued if a control flow merge
    changes the frame at some instruction.</li><li>The branching instructions. When a second (third, ..) control flow edge arrives at an
    instruction, the existing frame at the instruction is merged with the one computed on the
    new branch. If the merge function changes the existing frame, the instruction is enqueued
    for another analysis. This results in a merge operation for the successors of the
    instruction.</li><li>The number of local variables. The hot spot of analysis is frame merging. The merge function
    iterates through the values in the frame (locals and stack values) and merges them.</li></ul><p>I measured the running time of an analysis for two examples:</p><ul><li>Keep the number of locals and branching instructions constant, increase the number of
    instructions. The running time grows linearly with the method size.</li><li>Increase the size and number of locals in a method. The method size and number of locals
    grow in the same pace. Here, the running time increase is polynomial. It looks like the
    complexity is be #instructions * #locals^2 (see below).</li></ul><p>I measured nullness analysis (which tracks aliases) and a SimpleValue analysis. Nullness runs
roughly 5x slower (because of alias tracking) at every problem size - this factor doesn't change.</p><p>The numbers below are for nullness. Note that the last column is constant, i.e., the running
time is proportional to #ins * #loc^2. Therefore we use this factor when limiting the maximal
method size for running an analysis.</p><p>  #insns    #locals    time (ms)       time / #ins * #loc<sup>2 * 10</sup>6
  1305      156        34              1.07
  2610      311        165             0.65
  3915      466        490             0.57
  5220      621        1200            0.59
  6525      776        2220            0.56
  7830      931        3830            0.56
  9135      1086       6570            0.60
  10440     1241       9700            0.60
  11745     1396       13800           0.60</p><p>As a second experiment, nullness analysis was run with varying #insns but constant #locals.
The last column shows linear complexity with respect to the method size (linearOffset = 2279):</p><p>  #insns     #locals     time (ms)    (time + linearOffset) / #insns
  5220       621         1090         0.645
  6224       621         1690         0.637
  7226       621         2280         0.630
  8228       621         2870         0.625
  9230       621         3530         0.629
  10232      621         4130         0.626
  11234      621         4770         0.627
  12236      621         5520         0.637
  13238      621         6170         0.638</p><p>When running a BasicValue analysis, the complexity observation is the same (time is proportional
to #ins * #loc^2).</p><p>Measuring analysis execution time
---------------------------------</p><p>See code below.
</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/scala/scala/tree/v2.13.12src/compiler/scala/tools/nsc/backend/jvm/analysis/package.scala#L386" target="_blank">package.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="../../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.12/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div><div id="content-diagram-container" class="toggleContainer block diagram-container"><span class="toggle diagram-link">Content Hierarchy</span><div id="content-diagram" class="diagram hiddenContent"><svg id="graph1" class="package-diagram" width="800" height="600"></svg><script type="text/dot" id="dot1">
digraph G {
  
  
  node0 [URL="NullnessAnalyzer.html#inheritance-diagram-container", label="NullnessAnalyzer", id="graph1_0", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.NullnessAnalyzer"] ;
  node1 [URL="NullnessFrame.html#inheritance-diagram-container", label="NullnessFrame", id="graph1_1", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.NullnessFrame"] ;
  node2 [URL="NotNullValue$.html#inheritance-diagram-container", label="NotNullValue", id="graph1_2", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.NotNullValue"] ;
  node3 [URL="UnknownValue2$.html#inheritance-diagram-container", label="UnknownValue2", id="graph1_3", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.UnknownValue2"] ;
  node4 [URL="UnknownValue1$.html#inheritance-diagram-container", label="UnknownValue1", id="graph1_4", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.UnknownValue1"] ;
  node5 [URL="NullValue$.html#inheritance-diagram-container", label="NullValue", id="graph1_5", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.NullValue"] ;
  node6 [URL="NullnessValue.html#inheritance-diagram-container", label="NullnessValue", id="graph1_6", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.NullnessValue"] ;
  node7 [URL="NonLubbingTypeFlowAnalyzer.html#inheritance-diagram-container", label="NonLubbingTypeFlowAnalyzer", id="graph1_7", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.NonLubbingTypeFlowAnalyzer"] ;
  node8 [URL="NonLubbingTypeFlowInterpreter.html#inheritance-diagram-container", label="NonLubbingTypeFlowInterpreter", id="graph1_8", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.NonLubbingTypeFlowInterpreter"] ;
  node9 [URL="TypeFlowInterpreter.html#inheritance-diagram-container", label="TypeFlowInterpreter", id="graph1_9", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter"] ;
  node10 [URL="BasicAnalyzer.html#inheritance-diagram-container", label="BasicAnalyzer", id="graph1_10", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.BasicAnalyzer"] ;
  node11 [URL="AsmAnalyzer.html#inheritance-diagram-container", label="AsmAnalyzer[V]", id="graph1_11", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer"] ;
  node12 [URL="BasicAliasingAnalyzer.html#inheritance-diagram-container", label="BasicAliasingAnalyzer", id="graph1_12", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.BasicAliasingAnalyzer"] ;
  node13 [URL="AliasingAsmAnalyzerMarker.html#inheritance-diagram-container", label="AliasingAsmAnalyzerMarker", id="graph1_13", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.AliasingAsmAnalyzerMarker"] ;
  node14 [URL="AliasingFrame.html#inheritance-diagram-container", label="AliasingFrame[V]", id="graph1_14", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.AliasingFrame"] ;
  node15 [URL="ExceptionProducer.html#inheritance-diagram-container", label="ExceptionProducer[V]", id="graph1_15", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.ExceptionProducer"] ;
  node16 [URL="UninitializedLocalProducer.html#inheritance-diagram-container", label="UninitializedLocalProducer", id="graph1_16", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.UninitializedLocalProducer"] ;
  node17 [URL="ParameterProducer.html#inheritance-diagram-container", label="ParameterProducer", id="graph1_17", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.ParameterProducer"] ;
  node18 [URL="InitialProducer.html#inheritance-diagram-container", label="InitialProducer", id="graph1_18", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.InitialProducer"] ;
  node19 [URL="ProdConsAnalyzer.html#inheritance-diagram-container", label="ProdConsAnalyzer", id="graph1_19", class="default", tooltip="scala.tools.nsc.backend.jvm.analysis.ProdConsAnalyzer"] ;
  
  
  node11 -> node19 [arrowtail="empty", dir="back", id="graph1_11_19", class="inheritance", tooltip="ProdConsAnalyzer is a subtype of AsmAnalyzer[V]"] ;
  node18 -> node17 [arrowtail="empty", dir="back", id="graph1_18_17", class="inheritance", tooltip="ParameterProducer is a subtype of InitialProducer"] ;
  node18 -> node16 [arrowtail="empty", dir="back", id="graph1_18_16", class="inheritance", tooltip="UninitializedLocalProducer is a subtype of InitialProducer"] ;
  node18 -> node15 [arrowtail="empty", dir="back", id="graph1_18_15", class="inheritance", tooltip="ExceptionProducer[V] is a subtype of InitialProducer"] ;
  node11 -> node12 [arrowtail="empty", dir="back", id="graph1_11_12", class="inheritance", tooltip="BasicAliasingAnalyzer is a subtype of AsmAnalyzer[V]"] ;node13 -> node12 [arrowtail="empty", dir="back", id="graph1_13_12", class="inheritance", tooltip="BasicAliasingAnalyzer is a subtype of AliasingAsmAnalyzerMarker"] ;
  node11 -> node10 [arrowtail="empty", dir="back", id="graph1_11_10", class="inheritance", tooltip="BasicAnalyzer is a subtype of AsmAnalyzer[V]"] ;
  node9 -> node8 [arrowtail="empty", dir="back", id="graph1_9_8", class="inheritance", tooltip="NonLubbingTypeFlowInterpreter is a subtype of TypeFlowInterpreter"] ;
  node11 -> node7 [arrowtail="empty", dir="back", id="graph1_11_7", class="inheritance", tooltip="NonLubbingTypeFlowAnalyzer is a subtype of AsmAnalyzer[V]"] ;
  node6 -> node5 [arrowtail="empty", dir="back", id="graph1_6_5", class="inheritance", tooltip="NullValue is a subtype of NullnessValue"] ;
  node6 -> node4 [arrowtail="empty", dir="back", id="graph1_6_4", class="inheritance", tooltip="UnknownValue1 is a subtype of NullnessValue"] ;
  node6 -> node3 [arrowtail="empty", dir="back", id="graph1_6_3", class="inheritance", tooltip="UnknownValue2 is a subtype of NullnessValue"] ;
  node6 -> node2 [arrowtail="empty", dir="back", id="graph1_6_2", class="inheritance", tooltip="NotNullValue is a subtype of NullnessValue"] ;
  node14 -> node1 [arrowtail="empty", dir="back", id="graph1_14_1", class="inheritance", tooltip="NullnessFrame is a subtype of AliasingFrame[V]"] ;
  node11 -> node0 [arrowtail="empty", dir="back", id="graph1_11_0", class="inheritance", tooltip="NullnessAnalyzer is a subtype of AsmAnalyzer[V]"] ;node13 -> node0 [arrowtail="empty", dir="back", id="graph1_13_0", class="inheritance", tooltip="NullnessAnalyzer is a subtype of AliasingAsmAnalyzerMarker"] ;
}
</script><script>$("#inheritance-diagram").bind('beforeShow', function() {
  if ($("svg#graph1").children().length == 0) {
    var dot = document.querySelector("#dot1").text;
    var svg = d3.select("#graph1");
    var inner = svg.append("g");

    // Set up zoom support
    var zoom = d3.zoom()
        .on("zoom", function() {
          inner.attr("transform", d3.event.transform);
        });
    svg.call(zoom);

    var render = new dagreD3.render();
    var g = graphlibDot.read(dot);
    render(inner, g);

    inner.selectAll("g.node").each(function(v) {
      // https://stackoverflow.com/questions/27381452/wrapping-existing-inline-svg-g-element-with-a-element
      var tgt = $("#"+ g.node(v).id +" g.label text")[0];
      var parent = tgt.parentNode;
      var a = document.createElementNS('http://www.w3.org/2000/svg', 'a');
      a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', g.node(v).URL);
      a.appendChild(tgt);
      parent.appendChild(a);
    });
  }
})</script></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="scala.tools.nsc.backend.jvm.analysis"><span>analysis</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.AliasSet" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="AliasSetextendsAnyRef" class="anchorToMember"></a><a id="AliasSet:AliasSet" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/AliasSet.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="AliasSet.html" title="An efficient mutable bit set."><span class="name">AliasSet</span></a><span class="result"> extends <a href="../../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt">An efficient mutable bit set.</p></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.AliasingAnalyzer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="AliasingAnalyzer[V&lt;:scala.tools.asm.tree.analysis.Value]extendsAnalyzer[V]" class="anchorToMember"></a><a id="AliasingAnalyzer[V&lt;:Value]:AliasingAnalyzer[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/AliasingAnalyzer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="AliasingAnalyzer.html" title="An analyzer that uses AliasingFrames instead of bare Frames."><span class="name">AliasingAnalyzer</span></a><span class="tparams">[<span name="V">V &lt;: <span name="scala.tools.asm.tree.analysis.Value" class="extype">Value</span></span>]</span><span class="result"> extends <span name="scala.tools.asm.tree.analysis.Analyzer" class="extype">Analyzer</span>[<span name="scala.tools.nsc.backend.jvm.analysis.AliasingAnalyzer.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">An analyzer that uses AliasingFrames instead of bare Frames.</p><div class="fullcomment"><div class="comment cmt"><p>An analyzer that uses AliasingFrames instead of bare Frames. This can be used when an analysis
needs to track aliases, but doesn't require a more specific Frame subclass.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.AliasingAsmAnalyzerMarker" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="AliasingAsmAnalyzerMarkerextendsAnyRef" class="anchorToMember"></a><a id="AliasingAsmAnalyzerMarker:AliasingAsmAnalyzerMarker" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/AliasingAsmAnalyzerMarker.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="AliasingAsmAnalyzerMarker.html" title=""><span class="name">AliasingAsmAnalyzerMarker</span></a><span class="result"> extends <a href="../../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.AliasingFrame" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="AliasingFrame[V&lt;:scala.tools.asm.tree.analysis.Value]extendsFrame[V]" class="anchorToMember"></a><a id="AliasingFrame[V&lt;:Value]:AliasingFrame[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/AliasingFrame.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="AliasingFrame.html" title="A subclass of Frame that tracks aliasing of values stored in local variables and on the stack."><span class="name">AliasingFrame</span></a><span class="tparams">[<span name="V">V &lt;: <span name="scala.tools.asm.tree.analysis.Value" class="extype">Value</span></span>]</span><span class="result"> extends <span name="scala.tools.asm.tree.analysis.Frame" class="extype">Frame</span>[<span name="scala.tools.nsc.backend.jvm.analysis.AliasingFrame.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">A subclass of Frame that tracks aliasing of values stored in local variables and on the stack.</p><div class="fullcomment"><div class="comment cmt"><p>A subclass of Frame that tracks aliasing of values stored in local variables and on the stack.</p><p>Note: an analysis tracking aliases is roughly 5x slower than a usual analysis (assuming a simple
value domain with a fast merge function). For example, nullness analysis is roughly 5x slower
than a BasicValue analysis.</p><p>See the doc of package object <code>analysis</code> for some notes on the performance of alias analysis.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="AsmAnalyzer[V&lt;:scala.tools.asm.tree.analysis.Value]extendsAnyRef" class="anchorToMember"></a><a id="AsmAnalyzer[V&lt;:Value]:AsmAnalyzer[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/AsmAnalyzer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="AsmAnalyzer.html" title="A wrapper to make ASM's Analyzer a bit easier to use."><span class="name">AsmAnalyzer</span></a><span class="tparams">[<span name="V">V &lt;: <span name="scala.tools.asm.tree.analysis.Value" class="extype">Value</span></span>]</span><span class="result"> extends <a href="../../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt">A wrapper to make ASM's Analyzer a bit easier to use.</p></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.BackendUtils" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="BackendUtilsextendsPerRunInit" class="anchorToMember"></a><a id="BackendUtils:BackendUtils" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/BackendUtils.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BackendUtils.html" title="This component hosts tools and utilities used in the backend that require access to a BTypes instance."><span class="name">BackendUtils</span></a><span class="result"> extends <a href="../PerRunInit.html" name="scala.tools.nsc.backend.jvm.PerRunInit" id="scala.tools.nsc.backend.jvm.PerRunInit" class="extype">PerRunInit</a></span></span><p class="shortcomment cmt">This component hosts tools and utilities used in the backend that require access to a <code>BTypes</code>
instance.</p><div class="fullcomment"><div class="comment cmt"><p>This component hosts tools and utilities used in the backend that require access to a <code>BTypes</code>
instance.</p><p>TODO: move out of <code>analysis</code> package?
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.BasicAliasingAnalyzer" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="BasicAliasingAnalyzerextendsAsmAnalyzer[scala.tools.asm.tree.analysis.BasicValue]withAliasingAsmAnalyzerMarker" class="anchorToMember"></a><a id="BasicAliasingAnalyzer:BasicAliasingAnalyzer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/BasicAliasingAnalyzer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="BasicAliasingAnalyzer.html" title=""><span class="name">BasicAliasingAnalyzer</span></a><span class="result"> extends <a href="AsmAnalyzer.html" name="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" id="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" class="extype">AsmAnalyzer</a>[<span name="scala.tools.asm.tree.analysis.BasicValue" class="extype">BasicValue</span>] with <a href="AliasingAsmAnalyzerMarker.html" name="scala.tools.nsc.backend.jvm.analysis.AliasingAsmAnalyzerMarker" id="scala.tools.nsc.backend.jvm.analysis.AliasingAsmAnalyzerMarker" class="extype">AliasingAsmAnalyzerMarker</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.BasicAnalyzer" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="BasicAnalyzerextendsAsmAnalyzer[scala.tools.asm.tree.analysis.BasicValue]" class="anchorToMember"></a><a id="BasicAnalyzer:BasicAnalyzer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/BasicAnalyzer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="BasicAnalyzer.html" title=""><span class="name">BasicAnalyzer</span></a><span class="result"> extends <a href="AsmAnalyzer.html" name="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" id="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" class="extype">AsmAnalyzer</a>[<span name="scala.tools.asm.tree.analysis.BasicValue" class="extype">BasicValue</span>]</span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.ExceptionProducer" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ExceptionProducer[V&lt;:scala.tools.asm.tree.analysis.Value]extendsInitialProducerwithProductwithSerializable" class="anchorToMember"></a><a id="ExceptionProducer[V&lt;:Value]:ExceptionProducer[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/ExceptionProducer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="ExceptionProducer.html" title=""><span class="name">ExceptionProducer</span></a><span class="tparams">[<span name="V">V &lt;: <span name="scala.tools.asm.tree.analysis.Value" class="extype">Value</span></span>]</span><span class="params">(<span name="handlerLabel">handlerLabel: <span name="scala.tools.asm.tree.LabelNode" class="extype">LabelNode</span></span>, <span name="handlerStackTop">handlerStackTop: <a href="https://www.scala-lang.org/api/2.13.12/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result"> extends <a href="InitialProducer.html" name="scala.tools.nsc.backend.jvm.analysis.InitialProducer" id="scala.tools.nsc.backend.jvm.analysis.InitialProducer" class="extype">InitialProducer</a> with <a href="https://www.scala-lang.org/api/2.13.12/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <a href="../../../../../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.InitialProducer" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="InitialProducerextendsAbstractInsnNode" class="anchorToMember"></a><a id="InitialProducer:InitialProducer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/InitialProducer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="InitialProducer.html" title="A class for pseudo-instructions representing the initial producers of local values that have no producer instruction in the method:"><span class="name">InitialProducer</span></a><span class="result"> extends <span name="scala.tools.asm.tree.AbstractInsnNode" class="extype">AbstractInsnNode</span></span></span><p class="shortcomment cmt">A class for pseudo-instructions representing the initial producers of local values that have
no producer instruction in the method:</p><div class="fullcomment"><div class="comment cmt"><p>A class for pseudo-instructions representing the initial producers of local values that have
no producer instruction in the method:</p><ul><li>parameters, including <code>this</code></li><li>uninitialized local variables</li><li>exception values in handlers</li></ul><p>The ASM built-in SourceValue analysis yields an empty producers set for such values. This leads
to ambiguities. Example (in Java one can re-assign parameter):</p><p>  int foo(int a) {
    if (a == 0) a = 1;
    return a;
  }</p><p>In the first frame of the method, the SourceValue for parameter <code>a</code> gives an empty set of
producer instructions.</p><p>In the frame of the <code>IRETURN</code> instruction, the SourceValue for parameter <code>a</code> lists a single
producer instruction: the <code>ISTORE 1</code>. This makes it look as if there was a single producer for
<code>a</code>, where in fact it might still hold the parameter's initial value.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.InitialProducerSourceInterpreter" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="InitialProducerSourceInterpreterextendsSourceInterpreter" class="anchorToMember"></a><a id="InitialProducerSourceInterpreter:InitialProducerSourceInterpreter" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/InitialProducerSourceInterpreter.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="InitialProducerSourceInterpreter.html" title=""><span class="name">InitialProducerSourceInterpreter</span></a><span class="result"> extends <span name="scala.tools.asm.tree.analysis.SourceInterpreter" class="extype">SourceInterpreter</span></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.IntIterator" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="IntIteratorextendsAbstractIterator[Int]" class="anchorToMember"></a><a id="IntIterator:IntIterator" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/IntIterator.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="IntIterator.html" title="An iterator over Int (required to prevent boxing the result of next)."><span class="name">IntIterator</span></a><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.12/scala/collection/AbstractIterator.html#scala.collection.AbstractIterator" name="scala.collection.AbstractIterator" id="scala.collection.AbstractIterator" class="extype">AbstractIterator</a>[<a href="https://www.scala-lang.org/api/2.13.12/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>]</span></span><p class="shortcomment cmt">An iterator over Int (required to prevent boxing the result of next).</p></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NonLubbingTypeFlowAnalyzer" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NonLubbingTypeFlowAnalyzerextendsAsmAnalyzer[scala.tools.asm.tree.analysis.BasicValue]" class="anchorToMember"></a><a id="NonLubbingTypeFlowAnalyzer:NonLubbingTypeFlowAnalyzer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NonLubbingTypeFlowAnalyzer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="NonLubbingTypeFlowAnalyzer.html" title=""><span class="name">NonLubbingTypeFlowAnalyzer</span></a><span class="result"> extends <a href="AsmAnalyzer.html" name="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" id="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" class="extype">AsmAnalyzer</a>[<span name="scala.tools.asm.tree.analysis.BasicValue" class="extype">BasicValue</span>]</span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NonLubbingTypeFlowInterpreter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="NonLubbingTypeFlowInterpreterextendsTypeFlowInterpreter" class="anchorToMember"></a><a id="NonLubbingTypeFlowInterpreter:NonLubbingTypeFlowInterpreter" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NonLubbingTypeFlowInterpreter.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="NonLubbingTypeFlowInterpreter.html" title="A TypeFlowInterpreter which collapses LUBs of non-equal reference types to Object."><span class="name">NonLubbingTypeFlowInterpreter</span></a><span class="result"> extends <a href="TypeFlowInterpreter.html" name="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter" id="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter" class="extype">TypeFlowInterpreter</a></span></span><p class="shortcomment cmt">A <a href="TypeFlowInterpreter.html" name="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter" id="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter" class="extype">TypeFlowInterpreter</a> which collapses LUBs of non-equal reference types to Object.</p><div class="fullcomment"><div class="comment cmt"><p>A <a href="TypeFlowInterpreter.html" name="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter" id="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter" class="extype">TypeFlowInterpreter</a> which collapses LUBs of non-equal reference types to Object.
This could be made more precise by looking up ClassBTypes for the two reference types and using
the <code>jvmWiseLUB</code> method.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NullnessAnalyzer" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NullnessAnalyzerextendsAsmAnalyzer[scala.tools.nsc.backend.jvm.analysis.NullnessValue]withAliasingAsmAnalyzerMarker" class="anchorToMember"></a><a id="NullnessAnalyzer:NullnessAnalyzer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NullnessAnalyzer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="NullnessAnalyzer.html" title=""><span class="name">NullnessAnalyzer</span></a><span class="result"> extends <a href="AsmAnalyzer.html" name="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" id="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" class="extype">AsmAnalyzer</a>[<a href="NullnessValue.html" name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" id="scala.tools.nsc.backend.jvm.analysis.NullnessValue" class="extype">NullnessValue</a>] with <a href="AliasingAsmAnalyzerMarker.html" name="scala.tools.nsc.backend.jvm.analysis.AliasingAsmAnalyzerMarker" id="scala.tools.nsc.backend.jvm.analysis.AliasingAsmAnalyzerMarker" class="extype">AliasingAsmAnalyzerMarker</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NullnessAnalyzerImpl" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NullnessAnalyzerImplextendsAnalyzer[scala.tools.nsc.backend.jvm.analysis.NullnessValue]" class="anchorToMember"></a><a id="NullnessAnalyzerImpl:NullnessAnalyzerImpl" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NullnessAnalyzerImpl.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="NullnessAnalyzerImpl.html" title=""><span class="name">NullnessAnalyzerImpl</span></a><span class="result"> extends <span name="scala.tools.asm.tree.analysis.Analyzer" class="extype">Analyzer</span>[<a href="NullnessValue.html" name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" id="scala.tools.nsc.backend.jvm.analysis.NullnessValue" class="extype">NullnessValue</a>]</span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NullnessFrame" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NullnessFrameextendsAliasingFrame[scala.tools.nsc.backend.jvm.analysis.NullnessValue]" class="anchorToMember"></a><a id="NullnessFrame:NullnessFrame" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NullnessFrame.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="NullnessFrame.html" title=""><span class="name">NullnessFrame</span></a><span class="result"> extends <a href="AliasingFrame.html" name="scala.tools.nsc.backend.jvm.analysis.AliasingFrame" id="scala.tools.nsc.backend.jvm.analysis.AliasingFrame" class="extype">AliasingFrame</a>[<a href="NullnessValue.html" name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" id="scala.tools.nsc.backend.jvm.analysis.NullnessValue" class="extype">NullnessValue</a>]</span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NullnessInterpreter" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NullnessInterpreterextendsInterpreter[scala.tools.nsc.backend.jvm.analysis.NullnessValue]" class="anchorToMember"></a><a id="NullnessInterpreter:NullnessInterpreter" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NullnessInterpreter.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="NullnessInterpreter.html" title=""><span class="name">NullnessInterpreter</span></a><span class="result"> extends <span name="scala.tools.asm.tree.analysis.Interpreter" class="extype">asm.tree.analysis.Interpreter</span>[<a href="NullnessValue.html" name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" id="scala.tools.nsc.backend.jvm.analysis.NullnessValue" class="extype">NullnessValue</a>]</span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="NullnessValueextendsValue" class="anchorToMember"></a><a id="NullnessValue:NullnessValue" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NullnessValue.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="NullnessValue.html" title="Represents the nullness state for a local variable or stack value."><span class="name">NullnessValue</span></a><span class="result"> extends <span name="scala.tools.asm.tree.analysis.Value" class="extype">Value</span></span></span><p class="shortcomment cmt">Represents the nullness state for a local variable or stack value.</p><div class="fullcomment"><div class="comment cmt"><p>Represents the nullness state for a local variable or stack value.</p><p>Note that nullness of primitive values is not tracked, it will be always unknown.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.ParameterProducer" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ParameterProducerextendsInitialProducerwithProductwithSerializable" class="anchorToMember"></a><a id="ParameterProducer:ParameterProducer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/ParameterProducer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="ParameterProducer.html" title=""><span class="name">ParameterProducer</span></a><span class="params">(<span name="local">local: <a href="https://www.scala-lang.org/api/2.13.12/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result"> extends <a href="InitialProducer.html" name="scala.tools.nsc.backend.jvm.analysis.InitialProducer" id="scala.tools.nsc.backend.jvm.analysis.InitialProducer" class="extype">InitialProducer</a> with <a href="https://www.scala-lang.org/api/2.13.12/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <a href="../../../../../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.ProdConsAnalyzer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ProdConsAnalyzerextendsAsmAnalyzer[scala.tools.asm.tree.analysis.SourceValue]" class="anchorToMember"></a><a id="ProdConsAnalyzer:ProdConsAnalyzer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/ProdConsAnalyzer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="ProdConsAnalyzer.html" title="This class provides additional queries over ASM's built-in SourceValue analysis."><span class="name">ProdConsAnalyzer</span></a><span class="result"> extends <a href="AsmAnalyzer.html" name="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" id="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" class="extype">AsmAnalyzer</a>[<span name="scala.tools.asm.tree.analysis.SourceValue" class="extype">SourceValue</span>]</span></span><p class="shortcomment cmt">This class provides additional queries over ASM's built-in <code>SourceValue</code> analysis.</p><div class="fullcomment"><div class="comment cmt"><p>This class provides additional queries over ASM's built-in <code>SourceValue</code> analysis.</p><p>The analysis computes for each value in a frame a set of source instructions, which are the
potential producers. Most instructions produce either nothing or a stack value. For example,
a <code>LOAD</code> instruction is the producer of the value pushed onto the stack. The exception are
<code>STORE</code> instructions, which produce a new value for a local variable slot, so they are used
as producers for the value they stored.</p><p>Note that pseudo-instructions are used as initial producers for parameters and local variables.
See the documentation on class InitialProducer.</p><p>This class implements the following queries over the data computed by the SourceValue analysis:</p><ul><li>producersForValueAt(insn, slot)</li><li>consumersOfValueAt(insn, slot)</li><li>producersForInputsOf(insn)</li><li>consumersOfOutputsFrom(insn)</li><li>initialProducersForValueAt(insn, slot)</li><li>ultimateConsumersOfValueAt(insn, slot)</li><li>initialProducersForInputsOf(insn)</li><li>ultimateConsumersOfOutputsFrom(insn)</li></ul><p>The following operations are considered as copying operations:</p><ul><li>xLOAD, xSTORE</li><li>DUP, DUP2, DUP_X1, DUP_X2, DUP2_X1, DUP2_X2</li><li>SWAP</li><li>CHECKCAST</li></ul><p>If ever needed, we could introduce a mode where primitive conversions (l2i) are considered as
copying operations.</p><p>Note on performance: thee data flow analysis (SourceValue / SourceInterpreter, provided by ASM)
is roughly 2-3x slower than a simple analysis (like BasicValue). The reason is that the merge
function (merging producer sets) is more complex than merging simple basic values.
See also the doc comment in the package object <code>analysis</code>.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="TypeFlowInterpreterextendsBasicInterpreter" class="anchorToMember"></a><a id="TypeFlowInterpreter:TypeFlowInterpreter" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/TypeFlowInterpreter.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="TypeFlowInterpreter.html" title=""><span class="name">TypeFlowInterpreter</span></a><span class="result"> extends <span name="scala.tools.asm.tree.analysis.BasicInterpreter" class="extype">BasicInterpreter</span></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.UninitializedLocalProducer" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="UninitializedLocalProducerextendsInitialProducerwithProductwithSerializable" class="anchorToMember"></a><a id="UninitializedLocalProducer:UninitializedLocalProducer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/UninitializedLocalProducer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="UninitializedLocalProducer.html" title=""><span class="name">UninitializedLocalProducer</span></a><span class="params">(<span name="local">local: <a href="https://www.scala-lang.org/api/2.13.12/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result"> extends <a href="InitialProducer.html" name="scala.tools.nsc.backend.jvm.analysis.InitialProducer" id="scala.tools.nsc.backend.jvm.analysis.InitialProducer" class="extype">InitialProducer</a> with <a href="https://www.scala-lang.org/api/2.13.12/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <a href="../../../../../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.AliasSet" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="AliasSet" class="anchorToMember"></a><a id="AliasSet:AliasSet" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/AliasSet$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="AliasSet$.html" title=""><span class="name">AliasSet</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.AsmAnalyzer" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="AsmAnalyzer" class="anchorToMember"></a><a id="AsmAnalyzer:AsmAnalyzer" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/AsmAnalyzer$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="AsmAnalyzer$.html" title="See the doc comment on package object analysis for a discussion on performance."><span class="name">AsmAnalyzer</span></a></span><p class="shortcomment cmt">See the doc comment on package object <code>analysis</code> for a discussion on performance.</p></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.BackendUtils" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="BackendUtils" class="anchorToMember"></a><a id="BackendUtils:BackendUtils" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/BackendUtils$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="BackendUtils$.html" title=""><span class="name">BackendUtils</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.InstructionStackEffect" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="InstructionStackEffect" class="anchorToMember"></a><a id="InstructionStackEffect:InstructionStackEffect" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/InstructionStackEffect$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="InstructionStackEffect$.html" title=""><span class="name">InstructionStackEffect</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NotNullValue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NotNullValue" class="anchorToMember"></a><a id="NotNullValue:NotNullValue" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NotNullValue$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NotNullValue$.html" title=""><span class="name">NotNullValue</span></a><span class="result"> extends <a href="NullnessValue.html" name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" id="scala.tools.nsc.backend.jvm.analysis.NullnessValue" class="extype">NullnessValue</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NullValue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NullValue" class="anchorToMember"></a><a id="NullValue:NullValue" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NullValue$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NullValue$.html" title=""><span class="name">NullValue</span></a><span class="result"> extends <a href="NullnessValue.html" name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" id="scala.tools.nsc.backend.jvm.analysis.NullnessValue" class="extype">NullnessValue</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NullnessValue" class="anchorToMember"></a><a id="NullnessValue:NullnessValue" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/NullnessValue$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="NullnessValue$.html" title=""><span class="name">NullnessValue</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.TypeFlowInterpreter" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="TypeFlowInterpreter" class="anchorToMember"></a><a id="TypeFlowInterpreter:TypeFlowInterpreter" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/TypeFlowInterpreter$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TypeFlowInterpreter$.html" title=""><span class="name">TypeFlowInterpreter</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.UnknownValue1" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="UnknownValue1" class="anchorToMember"></a><a id="UnknownValue1:UnknownValue1" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/UnknownValue1$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="UnknownValue1$.html" title=""><span class="name">UnknownValue1</span></a><span class="result"> extends <a href="NullnessValue.html" name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" id="scala.tools.nsc.backend.jvm.analysis.NullnessValue" class="extype">NullnessValue</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis.UnknownValue2" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="UnknownValue2" class="anchorToMember"></a><a id="UnknownValue2:UnknownValue2" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../../scala/tools/nsc/backend/jvm/analysis/UnknownValue2$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="UnknownValue2$.html" title=""><span class="name">UnknownValue2</span></a><span class="result"> extends <a href="NullnessValue.html" name="scala.tools.nsc.backend.jvm.analysis.NullnessValue" id="scala.tools.nsc.backend.jvm.analysis.NullnessValue" class="extype">NullnessValue</a></span></span></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="../../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.12/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer">Scala programming documentation. Copyright (c) 2002-2023 <a href="https://www.epfl.ch" target="_top">EPFL</a> and <a href="https://www.lightbend.com" target="_top">Lightbend</a>.</div></body></div></div></div></body></html>
