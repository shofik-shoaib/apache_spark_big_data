<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Scala Compiler 2.13.12 - scala.tools.nsc.backend.jvm</title><meta content="Scala Compiler 2.13.12 - scala.tools.nsc.backend.jvm" name="description"/><meta content="Scala Compiler 2.13.12 scala.tools.nsc.backend.jvm" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../../../lib/index.js"></script><script type="text/javascript" src="../../../../../index.js"></script><script type="text/javascript" src="../../../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../../../lib/template.js"></script><script type="text/javascript" src="https://d3js.org/d3.v4.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../../../';</script></head><body><div id="search"><span id="doc-title">Scala Compiler<span id="doc-version">2.13.12</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../../../index.html" title="The Scala compiler and reflection APIs."><span class="name">root</span></a></span><p class="shortcomment cmt">The Scala compiler and reflection APIs.</p><div class="fullcomment"><div class="comment cmt"><p>The Scala compiler and reflection APIs.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.scala" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scala" class="anchorToMember"></a><a id="scala:scala" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../../index.html" title=""><span class="name">scala</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="scala.tools" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tools" class="anchorToMember"></a><a id="tools:tools" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">tools</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../index.html" name="scala" id="scala" class="extype">scala</a></dd></dl></div></li><li class="indented3 " name="scala.tools.nsc" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="nsc" class="anchorToMember"></a><a id="nsc:nsc" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">nsc</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="scala.tools" id="scala.tools" class="extype">tools</a></dd></dl></div></li><li class="indented4 " name="scala.tools.nsc.backend" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="backend" class="anchorToMember"></a><a id="backend:backend" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">backend</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="scala.tools.nsc" id="scala.tools.nsc" class="extype">nsc</a></dd></dl></div></li><li class="indented5 current" name="scala.tools.nsc.backend.jvm" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="jvm" class="anchorToMember"></a><a id="jvm:jvm" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">jvm</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="scala.tools.nsc.backend" id="scala.tools.nsc.backend" class="extype">backend</a></dd></dl></div></li><li class="indented6 " name="scala.tools.nsc.backend.jvm.analysis" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="analysis" class="anchorToMember"></a><a id="analysis:analysis" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/analysis/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="analysis/index.html" title="Summary on the ASM analyzer framework --------------------------------------"><span class="name">analysis</span></a></span><p class="shortcomment cmt">Summary on the ASM analyzer framework
--------------------------------------</p><div class="fullcomment"><div class="comment cmt"><p>Summary on the ASM analyzer framework
--------------------------------------</p><p>Value</p><ul><li>Abstract, needs to be implemented for each analysis.</li><li>Represents the desired information about local variables and stack values, for example:<ul><li>Is this value known to be null / not null?</li><li>What are the instructions that could potentially have produced this value?</li></ul></li></ul><p>Interpreter</p><ul><li>Abstract, needs to be implemented for each analysis. Sometimes one can subclass an existing
   interpreter, e.g., SourceInterpreter or BasicInterpreter.</li><li>Multiple abstract methods that receive an instruction and the instruction's input values, and
   return a value representing the result of that instruction.<ul><li>Note: due to control flow, the interpreter can be invoked multiple times for the same
     instruction, until reaching a fixed point.</li></ul></li><li>Abstract <code>merge</code> function that computes the least upper bound of two values. Used by
   Frame.merge (see below).</li></ul><p>Frame</p><ul><li>Can be used directly for many analyses, no subclass required.</li><li>Every frame has an array of values: one for each local variable and for each stack slot.<ul><li>A <code>top</code> index stores the index of the current stack top</li><li>NOTE: for a size-2 local variable at index i, the local variable at i+1 is set to an empty
     value. However, for a size-2 value at index i on the stack, the value at i+1 holds the next
     stack value. IMPORTANT: this is only the case in ASM's analysis framework, not in bytecode.
     See comment below.</li></ul></li><li>Defines the <code>execute(instruction)</code> method.<ul><li>executing mutates the state of the frame according to the effect of the instruction<ul><li>pop consumed values from the stack</li><li>pass them to the interpreter together with the instruction</li><li>if applicable, push the resulting value on the stack</li></ul></li></ul></li><li>Defines the <code>merge(otherFrame)</code> method<ul><li>called by the analyzer when multiple control flow paths lead to an instruction<ul><li>the frame at the branching instruction is merged into the current frame of the
       instruction (held by the analyzer)</li><li>mutates the values of the current frame, merges all values using interpreter.merge.</li></ul></li></ul></li></ul><p>Analyzer</p><ul><li>Stores a frame for each instruction</li><li><code>merge</code> function takes an instruction and a frame, merges the existing frame for that instr
    (from the frames array) with the new frame passed as argument.
    if the frame changed, puts the instruction on the work queue (fixpoint).</li><li>initial frame: initialized for first instr by calling interpreter.new[...]Value
    for each slot (locals and params), stored in frames[firstInstr] by calling <code>merge</code></li><li>work queue of instructions (<code>queue</code> array, <code>top</code> index for next instruction to analyze)</li><li>analyze(method): simulate control flow. while work queue non-empty:<ul><li>copy the state of <code>frames[instr]</code> into a local frame <code>current</code></li><li>call <code>current.execute(instr, interpreter)</code>, mutating the <code>current</code> frame</li><li>if it's a branching instruction<ul><li>for all potential destination instructions<ul><li>merge the destination instruction frame with the <code>current</code> frame
          (this enqueues the destination instr if its frame changed)</li></ul></li><li>invoke <code>newControlFlowEdge</code> (see below)</li></ul></li></ul></li><li>the analyzer also tracks active exception handlers at each instruction</li><li>the empty method <code>newControlFlowEdge</code> can be overridden to track control flow if required</li></ul><p>MaxLocals and MaxStack
----------------------</p><p>At the JVM level, long and double values occupy two slots, both as local variables and on the
stack, as specified in the JVM spec 2.6.2:
  "At any point in time, an operand stack has an associated depth, where a value of type long or
   double contributes two units to the depth and a value of any other type contributes one unit."</p><p>For example, a method
  class A { def f(a: Long, b: Long) = a + b }
has MAXSTACK=4 in the classfile. This value is computed by the ClassWriter / MethodWriter when
generating the classfile (we always pass COMPUTE_MAXS to the ClassWriter).</p><p>For running an ASM Analyzer, long and double values occupy two local variable slots, but only
a single slot on the call stack, as shown by the following snippet:</p><p>  import scala.tools.nsc.backend.jvm._
  import scala.tools.nsc.backend.jvm.opt.BytecodeUtils._
  import scala.collection.convert.decorateAsScala._
  import scala.tools.asm.tree.analysis._</p><p>  val cn = AsmUtils.readClass("/Users/luc/scala/scala/sandbox/A.class")
  val m = cn.methods.iterator.asScala.find(_.name == "f").head</p><p>  // the value is read from the classfile, so it's 4
  println(s"maxLocals: ${m.maxLocals}, maxStack: ${m.maxStack}") // maxLocals: 5, maxStack: 4</p><p>  // we can safely set it to 2 for running the analyzer.
  m.maxStack = 2</p><p>  val a = new Analyzer(new BasicInterpreter)
  a.analyze(cn.name, m)
  val addInsn = m.instructions.iterator.asScala.find(_.getOpcode == 97).get // LADD Opcode
  val addFrame = a.frameAt(addInsn, m)</p><p>  addFrame.getStackSize // 2: the two long values only take one slot each
  addFrame.getLocals    // 5: this takes one slot, the two long parameters take 2 slots each</p><p>While running the optimizer, we need to make sure that the <code>maxStack</code> value of a method is
large enough for running an ASM analyzer. We don't need to worry if the value is incorrect in
the JVM perspective: the value will be re-computed and overwritten in the ClassWriter.</p><p>Lessons learnt while benchmarking the alias tracking analysis
-------------------------------------------------------------</p><p>Profiling</p><ul><li>Use YourKit for finding hotspots (cpu profiling). when it comes to drilling down into the details
   of a hotspot, don't pay too much attention to the percentages / time counts.</li><li>Should also try other profilers.</li><li>Use timers. When a method showed up as a hotspot, I added a timer around that method, and a
   second one within the method to measure specific parts. The timers slow things down, but the
   relative numbers show what parts of a method are slow.</li></ul><p>ASM analyzer insights</p><ul><li>The time for running an analysis depends on the number of locals and the number of instructions.
   Reducing the number of locals helps speeding up the analysis: there are less values to
   merge when merging to frames.
   See also https://github.com/scala/scala-dev/issues/47</li><li>The common hot spot of an ASM analysis is Frame.merge, for example in producers / consumers.</li><li>For nullness analysis the time is spent as follows<ul><li>20% merging nullness values. this is as expected: for example, the same absolute amount of
     time is spent in merging BasicValues when running a BasicInterpreter.</li><li>50% merging alias sets. i tried to optimize what i could out of this.</li><li>20% is spent creating new frames from existing ones, see comment on AliasingFrame.init.</li></ul></li><li>The implementation of Frame.merge (the main hot spot) contains a megamorphic callsite to
   <code>interpreter.merge</code>. This can be observed easily by running a test program that either runs
   a BasicValue analysis only, versus a program that first runs a nullness analysis and then
   a BasicValue. In an example, the time for the BasicValue analysis goes from 519ms to 1963ms,
   a 3.8x slowdown.</li><li>I added counters to the Frame.merge methods for nullness and BasicValue analysis. In the
   examples I benchmarked, the number of merge invocations was always exactly the same.
   It would probably be possible to come up with an example where alias set merging forces
   additional analysis rounds until reaching the fixpoint, but I did not observe such cases.</li></ul><p>To benchmark an analysis, instead of benchmarking analysis while it runs in the compiler
backend, one can easily run it from a separate program (or the repl). The bytecode to analyze
can simply be parsed from a classfile. See example at the end of this comment.</p><p>Nullness Analysis in Miguel's Optimizer
---------------------------------------</p><p>Miguel implemented alias tracking for nullness analysis differently [1]. Remember that every
frame has an array of values. Miguel's idea was to represent aliasing using reference equality
in the values array: if two entries in the array point to the same value object, the two entries
are aliases in the frame of the given instruction.</p><p>While this idea seems elegant at first sight, Miguel's implementation does not merge frames
correctly when it comes to aliasing. Assume in frame 1, values (a, b, c) are aliases, while in
frame 2 (a, b) are aliases. When merging the second into the first, we have to make sure that
c is removed as an alias of (a, b).</p><p>It would be possible to implement correct alias set merging in Miguel's approach. However, frame
merging is the main hot spot of analysis. The computational complexity of implementing alias set
merging by traversing the values array and comparing references is too high. The concrete
alias set representation that is used in the current implementation (see class AliasingFrame)
makes alias set merging more efficient.</p><p>[1] https://github.com/scala-opt/scala/blob/opt/rebase/src/compiler/scala/tools/nsc/backend/bcode/NullnessPropagator.java</p><p>Complexity and scaling of analysis
----------------------------------</p><p>The time complexity of a data flow analysis depends on:</p><ul><li>The size of the method. The complexity factor is linear (assuming the number of locals and
    branching instructions remains constant). The main analysis loop runs through all
    instructions of a method once. Instructions are only re-enqueued if a control flow merge
    changes the frame at some instruction.</li><li>The branching instructions. When a second (third, ..) control flow edge arrives at an
    instruction, the existing frame at the instruction is merged with the one computed on the
    new branch. If the merge function changes the existing frame, the instruction is enqueued
    for another analysis. This results in a merge operation for the successors of the
    instruction.</li><li>The number of local variables. The hot spot of analysis is frame merging. The merge function
    iterates through the values in the frame (locals and stack values) and merges them.</li></ul><p>I measured the running time of an analysis for two examples:</p><ul><li>Keep the number of locals and branching instructions constant, increase the number of
    instructions. The running time grows linearly with the method size.</li><li>Increase the size and number of locals in a method. The method size and number of locals
    grow in the same pace. Here, the running time increase is polynomial. It looks like the
    complexity is be #instructions * #locals^2 (see below).</li></ul><p>I measured nullness analysis (which tracks aliases) and a SimpleValue analysis. Nullness runs
roughly 5x slower (because of alias tracking) at every problem size - this factor doesn't change.</p><p>The numbers below are for nullness. Note that the last column is constant, i.e., the running
time is proportional to #ins * #loc^2. Therefore we use this factor when limiting the maximal
method size for running an analysis.</p><p>  #insns    #locals    time (ms)       time / #ins * #loc<sup>2 * 10</sup>6
  1305      156        34              1.07
  2610      311        165             0.65
  3915      466        490             0.57
  5220      621        1200            0.59
  6525      776        2220            0.56
  7830      931        3830            0.56
  9135      1086       6570            0.60
  10440     1241       9700            0.60
  11745     1396       13800           0.60</p><p>As a second experiment, nullness analysis was run with varying #insns but constant #locals.
The last column shows linear complexity with respect to the method size (linearOffset = 2279):</p><p>  #insns     #locals     time (ms)    (time + linearOffset) / #insns
  5220       621         1090         0.645
  6224       621         1690         0.637
  7226       621         2280         0.630
  8228       621         2870         0.625
  9230       621         3530         0.629
  10232      621         4130         0.626
  11234      621         4770         0.627
  12236      621         5520         0.637
  13238      621         6170         0.638</p><p>When running a BasicValue analysis, the complexity observation is the same (time is proportional
to #ins * #loc^2).</p><p>Measuring analysis execution time
---------------------------------</p><p>See code below.
</p></div></div></li><li class="indented6 " name="scala.tools.nsc.backend.jvm.opt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="opt" class="anchorToMember"></a><a id="opt:opt" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/opt/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="opt/index.html" title=""><span class="name">opt</span></a></span></li><li class="current-entities indented5"><span class="separator"></span> <a href="AsmUtils$.html" title="" class="object"></a><a href="AsmUtils$.html" title="">AsmUtils</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="BCodeBodyBuilder.html" title="" class="class"></a><a href="BCodeBodyBuilder.html" title="">BCodeBodyBuilder</a></li><li class="current-entities indented5"><a href="BCodeHelpers$.html" title="" class="object"></a> <a href="BCodeHelpers.html" title="" class="class"></a><a href="BCodeHelpers.html" title="">BCodeHelpers</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="BCodeIdiomatic.html" title="" class="class"></a><a href="BCodeIdiomatic.html" title="">BCodeIdiomatic</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="BCodeSkelBuilder.html" title="" class="class"></a><a href="BCodeSkelBuilder.html" title="">BCodeSkelBuilder</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="BCodeSyncAndTry.html" title="" class="class"></a><a href="BCodeSyncAndTry.html" title="">BCodeSyncAndTry</a></li><li class="current-entities indented5"><a href="BTypes$.html" title="" class="object"></a> <a href="BTypes.html" title="The BTypes component defines The BType class hierarchy." class="class"></a><a href="BTypes.html" title="The BTypes component defines The BType class hierarchy.">BTypes</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="BTypesFromClassfile.html" title="" class="class"></a><a href="BTypesFromClassfile.html" title="">BTypesFromClassfile</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="BTypesFromSymbols.html" title="This class mainly contains the method classBTypeFromSymbol, which extracts the necessary information from a symbol and its type to create the corresponding ClassBType." class="class"></a><a href="BTypesFromSymbols.html" title="This class mainly contains the method classBTypeFromSymbol, which extracts the necessary information from a symbol and its type to create the corresponding ClassBType.">BTypesFromSymbols</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="BackendReporting$.html" title="Utilities for error reporting." class="object"></a><a href="BackendReporting$.html" title="Utilities for error reporting.">BackendReporting</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="BackendStats.html" title="" class="trait"></a><a href="BackendStats.html" title="">BackendStats</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="ClassNode1.html" title="A subclass of ClassNode to customize the representation of label nodes with LabelNode1." class="class"></a><a href="ClassNode1.html" title="A subclass of ClassNode to customize the representation of label nodes with LabelNode1.">ClassNode1</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="ClassfileWriters.html" title="" class="class"></a><a href="ClassfileWriters.html" title="">ClassfileWriters</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="ClearableJConcurrentHashMap.html" title="" class="class"></a><a href="ClearableJConcurrentHashMap.html" title="">ClearableJConcurrentHashMap</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="CodeGen.html" title="" class="class"></a><a href="CodeGen.html" title="">CodeGen</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="CompilationUnitInPostProcess.html" title="State for a compilation unit being post-processed." class="class"></a><a href="CompilationUnitInPostProcess.html" title="State for a compilation unit being post-processed.">CompilationUnitInPostProcess</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="CoreBTypes.html" title="" class="class"></a><a href="CoreBTypes.html" title="">CoreBTypes</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="CoreBTypesFromSymbols.html" title="" class="class"></a><a href="CoreBTypesFromSymbols.html" title="">CoreBTypesFromSymbols</a></li><li class="current-entities indented5"><a href="GenBCode$.html" title="" class="object"></a> <a href="GenBCode.html" title="Some notes about the backend's state and its initialization and release." class="class"></a><a href="GenBCode.html" title="Some notes about the backend's state and its initialization and release.">GenBCode</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="GeneratedClass.html" title="The result of code generation." class="class"></a><a href="GeneratedClass.html" title="The result of code generation.">GeneratedClass</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="GeneratedCompilationUnit.html" title="" class="class"></a><a href="GeneratedCompilationUnit.html" title="">GeneratedCompilationUnit</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="LabelNode1.html" title="A subclass of LabelNode to add user-definable flags." class="class"></a><a href="LabelNode1.html" title="A subclass of LabelNode to add user-definable flags.">LabelNode1</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="MethodNode1.html" title="A subclass of MethodNode to customize the representation of label nodes with LabelNode1." class="class"></a><a href="MethodNode1.html" title="A subclass of MethodNode to customize the representation of label nodes with LabelNode1.">MethodNode1</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="PerRunInit.html" title="Utility for backend components that have state that needs to be re-initialized at every compiler run, for example state that depends on compiler settings of frontend types (Symbols, Types)." class="trait"></a><a href="PerRunInit.html" title="Utility for backend components that have state that needs to be re-initialized at every compiler run, for example state that depends on compiler settings of frontend types (Symbols, Types).">PerRunInit</a></li><li class="current-entities indented5"><span class="separator"></span> <a href="PostProcessor.html" title="Implements late stages of the backend that don't depend on a Global instance, i.e., optimizations, post-processing and classfile serialization and writing." class="class"></a><a href="PostProcessor.html" title="Implements late stages of the backend that don't depend on a Global instance, i.e., optimizations, post-processing and classfile serialization and writing.">PostProcessor</a></li><li class="current-entities indented5"><a href="PostProcessorFrontendAccess$.html" title="" class="object"></a> <a href="PostProcessorFrontendAccess.html" title="Functionality needed in the post-processor whose implementation depends on the compiler frontend." class="class"></a><a href="PostProcessorFrontendAccess.html" title="Functionality needed in the post-processor whose implementation depends on the compiler frontend.">PostProcessorFrontendAccess</a></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../../../../index.html" name="scala" id="scala" class="extype">scala</a>.<a href="../../../index.html" name="scala.tools" id="scala.tools" class="extype">tools</a>.<a href="../../index.html" name="scala.tools.nsc" id="scala.tools.nsc" class="extype">nsc</a>.<a href="../index.html" name="scala.tools.nsc.backend" id="scala.tools.nsc.backend" class="extype">backend</a></p><h1>jvm<span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">jvm</span></span></h4><div id="comment" class="fullcommenttop"><div id="content-diagram-container" class="toggleContainer block diagram-container"><span class="toggle diagram-link">Content Hierarchy</span><div id="content-diagram" class="diagram hiddenContent"><svg id="graph1" class="package-diagram" width="800" height="600"></svg><script type="text/dot" id="dot1">
digraph G {
  
  
  node0 [URL="BTypesFromSymbols.html#inheritance-diagram-container", label="BTypesFromSymbols[G]", id="graph1_0", class="default", tooltip="scala.tools.nsc.backend.jvm.BTypesFromSymbols"] ;
  node1 [URL="CodeGen.html#inheritance-diagram-container", label="CodeGen[G]", id="graph1_1", class="default", tooltip="scala.tools.nsc.backend.jvm.CodeGen"] ;
  node2 [URL="BCodeSkelBuilder.html#inheritance-diagram-container", label="BCodeSkelBuilder", id="graph1_2", class="default", tooltip="scala.tools.nsc.backend.jvm.BCodeSkelBuilder"] ;
  node3 [URL="BCodeBodyBuilder.html#inheritance-diagram-container", label="BCodeBodyBuilder", id="graph1_3", class="default", tooltip="scala.tools.nsc.backend.jvm.BCodeBodyBuilder"] ;
  node4 [URL="PerRunInit.html#inheritance-diagram-container", label="PerRunInit", id="graph1_4", class="default", tooltip="scala.tools.nsc.backend.jvm.PerRunInit"] ;
  node5 [URL="BCodeIdiomatic.html#inheritance-diagram-container", label="BCodeIdiomatic", id="graph1_5", class="default", tooltip="scala.tools.nsc.backend.jvm.BCodeIdiomatic"] ;
  node6 [URL="CoreBTypesFromSymbols.html#inheritance-diagram-container", label="CoreBTypesFromSymbols[G]", id="graph1_6", class="default", tooltip="scala.tools.nsc.backend.jvm.CoreBTypesFromSymbols"] ;
  node7 [URL="CoreBTypes.html#inheritance-diagram-container", label="CoreBTypes", id="graph1_7", class="default", tooltip="scala.tools.nsc.backend.jvm.CoreBTypes"] ;
  node8 [URL="PostProcessor.html#inheritance-diagram-container", label="PostProcessor", id="graph1_8", class="default", tooltip="scala.tools.nsc.backend.jvm.PostProcessor"] ;
  node9 [URL="BTypes.html#inheritance-diagram-container", label="BTypes", id="graph1_9", class="default", tooltip="scala.tools.nsc.backend.jvm.BTypes"] ;
  node10 [URL="BCodeHelpers.html#inheritance-diagram-container", label="BCodeHelpers", id="graph1_10", class="default", tooltip="scala.tools.nsc.backend.jvm.BCodeHelpers"] ;
  node11 [URL="BCodeSyncAndTry.html#inheritance-diagram-container", label="BCodeSyncAndTry", id="graph1_11", class="default", tooltip="scala.tools.nsc.backend.jvm.BCodeSyncAndTry"] ;
  
  
  node3 -> node11 [arrowtail="empty", dir="back", id="graph1_3_11", class="inheritance", tooltip="BCodeSyncAndTry is a subtype of BCodeBodyBuilder"] ;
  node5 -> node10 [arrowtail="empty", dir="back", id="graph1_5_10", class="inheritance", tooltip="BCodeHelpers is a subtype of BCodeIdiomatic"] ;
  node4 -> node8 [arrowtail="empty", dir="back", id="graph1_4_8", class="inheritance", tooltip="PostProcessor is a subtype of PerRunInit"] ;
  node4 -> node7 [arrowtail="empty", dir="back", id="graph1_4_7", class="inheritance", tooltip="CoreBTypes is a subtype of PerRunInit"] ;
  node7 -> node6 [arrowtail="empty", dir="back", id="graph1_7_6", class="inheritance", tooltip="CoreBTypesFromSymbols[G] is a subtype of CoreBTypes"] ;
  node2 -> node3 [arrowtail="empty", dir="back", id="graph1_2_3", class="inheritance", tooltip="BCodeBodyBuilder is a subtype of BCodeSkelBuilder"] ;
  node10 -> node2 [arrowtail="empty", dir="back", id="graph1_10_2", class="inheritance", tooltip="BCodeSkelBuilder is a subtype of BCodeHelpers"] ;
  node4 -> node1 [arrowtail="empty", dir="back", id="graph1_4_1", class="inheritance", tooltip="CodeGen[G] is a subtype of PerRunInit"] ;
  node9 -> node0 [arrowtail="empty", dir="back", id="graph1_9_0", class="inheritance", tooltip="BTypesFromSymbols[G] is a subtype of BTypes"] ;
}
</script><script>$("#inheritance-diagram").bind('beforeShow', function() {
  if ($("svg#graph1").children().length == 0) {
    var dot = document.querySelector("#dot1").text;
    var svg = d3.select("#graph1");
    var inner = svg.append("g");

    // Set up zoom support
    var zoom = d3.zoom()
        .on("zoom", function() {
          inner.attr("transform", d3.event.transform);
        });
    svg.call(zoom);

    var render = new dagreD3.render();
    var g = graphlibDot.read(dot);
    render(inner, g);

    inner.selectAll("g.node").each(function(v) {
      // https://stackoverflow.com/questions/27381452/wrapping-existing-inline-svg-g-element-with-a-element
      var tgt = $("#"+ g.node(v).id +" g.label text")[0];
      var parent = tgt.parentNode;
      var a = document.createElementNS('http://www.w3.org/2000/svg', 'a');
      a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', g.node(v).URL);
      a.appendChild(tgt);
      parent.appendChild(a);
    });
  }
})</script></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="scala.tools.nsc.backend.jvm.analysis" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="analysis" class="anchorToMember"></a><a id="analysis:analysis" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/analysis/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="analysis/index.html" title="Summary on the ASM analyzer framework --------------------------------------"><span class="name">analysis</span></a></span><p class="shortcomment cmt">Summary on the ASM analyzer framework
--------------------------------------</p><div class="fullcomment"><div class="comment cmt"><p>Summary on the ASM analyzer framework
--------------------------------------</p><p>Value</p><ul><li>Abstract, needs to be implemented for each analysis.</li><li>Represents the desired information about local variables and stack values, for example:<ul><li>Is this value known to be null / not null?</li><li>What are the instructions that could potentially have produced this value?</li></ul></li></ul><p>Interpreter</p><ul><li>Abstract, needs to be implemented for each analysis. Sometimes one can subclass an existing
   interpreter, e.g., SourceInterpreter or BasicInterpreter.</li><li>Multiple abstract methods that receive an instruction and the instruction's input values, and
   return a value representing the result of that instruction.<ul><li>Note: due to control flow, the interpreter can be invoked multiple times for the same
     instruction, until reaching a fixed point.</li></ul></li><li>Abstract <code>merge</code> function that computes the least upper bound of two values. Used by
   Frame.merge (see below).</li></ul><p>Frame</p><ul><li>Can be used directly for many analyses, no subclass required.</li><li>Every frame has an array of values: one for each local variable and for each stack slot.<ul><li>A <code>top</code> index stores the index of the current stack top</li><li>NOTE: for a size-2 local variable at index i, the local variable at i+1 is set to an empty
     value. However, for a size-2 value at index i on the stack, the value at i+1 holds the next
     stack value. IMPORTANT: this is only the case in ASM's analysis framework, not in bytecode.
     See comment below.</li></ul></li><li>Defines the <code>execute(instruction)</code> method.<ul><li>executing mutates the state of the frame according to the effect of the instruction<ul><li>pop consumed values from the stack</li><li>pass them to the interpreter together with the instruction</li><li>if applicable, push the resulting value on the stack</li></ul></li></ul></li><li>Defines the <code>merge(otherFrame)</code> method<ul><li>called by the analyzer when multiple control flow paths lead to an instruction<ul><li>the frame at the branching instruction is merged into the current frame of the
       instruction (held by the analyzer)</li><li>mutates the values of the current frame, merges all values using interpreter.merge.</li></ul></li></ul></li></ul><p>Analyzer</p><ul><li>Stores a frame for each instruction</li><li><code>merge</code> function takes an instruction and a frame, merges the existing frame for that instr
    (from the frames array) with the new frame passed as argument.
    if the frame changed, puts the instruction on the work queue (fixpoint).</li><li>initial frame: initialized for first instr by calling interpreter.new[...]Value
    for each slot (locals and params), stored in frames[firstInstr] by calling <code>merge</code></li><li>work queue of instructions (<code>queue</code> array, <code>top</code> index for next instruction to analyze)</li><li>analyze(method): simulate control flow. while work queue non-empty:<ul><li>copy the state of <code>frames[instr]</code> into a local frame <code>current</code></li><li>call <code>current.execute(instr, interpreter)</code>, mutating the <code>current</code> frame</li><li>if it's a branching instruction<ul><li>for all potential destination instructions<ul><li>merge the destination instruction frame with the <code>current</code> frame
          (this enqueues the destination instr if its frame changed)</li></ul></li><li>invoke <code>newControlFlowEdge</code> (see below)</li></ul></li></ul></li><li>the analyzer also tracks active exception handlers at each instruction</li><li>the empty method <code>newControlFlowEdge</code> can be overridden to track control flow if required</li></ul><p>MaxLocals and MaxStack
----------------------</p><p>At the JVM level, long and double values occupy two slots, both as local variables and on the
stack, as specified in the JVM spec 2.6.2:
  "At any point in time, an operand stack has an associated depth, where a value of type long or
   double contributes two units to the depth and a value of any other type contributes one unit."</p><p>For example, a method
  class A { def f(a: Long, b: Long) = a + b }
has MAXSTACK=4 in the classfile. This value is computed by the ClassWriter / MethodWriter when
generating the classfile (we always pass COMPUTE_MAXS to the ClassWriter).</p><p>For running an ASM Analyzer, long and double values occupy two local variable slots, but only
a single slot on the call stack, as shown by the following snippet:</p><p>  import scala.tools.nsc.backend.jvm._
  import scala.tools.nsc.backend.jvm.opt.BytecodeUtils._
  import scala.collection.convert.decorateAsScala._
  import scala.tools.asm.tree.analysis._</p><p>  val cn = AsmUtils.readClass("/Users/luc/scala/scala/sandbox/A.class")
  val m = cn.methods.iterator.asScala.find(_.name == "f").head</p><p>  // the value is read from the classfile, so it's 4
  println(s"maxLocals: ${m.maxLocals}, maxStack: ${m.maxStack}") // maxLocals: 5, maxStack: 4</p><p>  // we can safely set it to 2 for running the analyzer.
  m.maxStack = 2</p><p>  val a = new Analyzer(new BasicInterpreter)
  a.analyze(cn.name, m)
  val addInsn = m.instructions.iterator.asScala.find(_.getOpcode == 97).get // LADD Opcode
  val addFrame = a.frameAt(addInsn, m)</p><p>  addFrame.getStackSize // 2: the two long values only take one slot each
  addFrame.getLocals    // 5: this takes one slot, the two long parameters take 2 slots each</p><p>While running the optimizer, we need to make sure that the <code>maxStack</code> value of a method is
large enough for running an ASM analyzer. We don't need to worry if the value is incorrect in
the JVM perspective: the value will be re-computed and overwritten in the ClassWriter.</p><p>Lessons learnt while benchmarking the alias tracking analysis
-------------------------------------------------------------</p><p>Profiling</p><ul><li>Use YourKit for finding hotspots (cpu profiling). when it comes to drilling down into the details
   of a hotspot, don't pay too much attention to the percentages / time counts.</li><li>Should also try other profilers.</li><li>Use timers. When a method showed up as a hotspot, I added a timer around that method, and a
   second one within the method to measure specific parts. The timers slow things down, but the
   relative numbers show what parts of a method are slow.</li></ul><p>ASM analyzer insights</p><ul><li>The time for running an analysis depends on the number of locals and the number of instructions.
   Reducing the number of locals helps speeding up the analysis: there are less values to
   merge when merging to frames.
   See also https://github.com/scala/scala-dev/issues/47</li><li>The common hot spot of an ASM analysis is Frame.merge, for example in producers / consumers.</li><li>For nullness analysis the time is spent as follows<ul><li>20% merging nullness values. this is as expected: for example, the same absolute amount of
     time is spent in merging BasicValues when running a BasicInterpreter.</li><li>50% merging alias sets. i tried to optimize what i could out of this.</li><li>20% is spent creating new frames from existing ones, see comment on AliasingFrame.init.</li></ul></li><li>The implementation of Frame.merge (the main hot spot) contains a megamorphic callsite to
   <code>interpreter.merge</code>. This can be observed easily by running a test program that either runs
   a BasicValue analysis only, versus a program that first runs a nullness analysis and then
   a BasicValue. In an example, the time for the BasicValue analysis goes from 519ms to 1963ms,
   a 3.8x slowdown.</li><li>I added counters to the Frame.merge methods for nullness and BasicValue analysis. In the
   examples I benchmarked, the number of merge invocations was always exactly the same.
   It would probably be possible to come up with an example where alias set merging forces
   additional analysis rounds until reaching the fixpoint, but I did not observe such cases.</li></ul><p>To benchmark an analysis, instead of benchmarking analysis while it runs in the compiler
backend, one can easily run it from a separate program (or the repl). The bytecode to analyze
can simply be parsed from a classfile. See example at the end of this comment.</p><p>Nullness Analysis in Miguel's Optimizer
---------------------------------------</p><p>Miguel implemented alias tracking for nullness analysis differently [1]. Remember that every
frame has an array of values. Miguel's idea was to represent aliasing using reference equality
in the values array: if two entries in the array point to the same value object, the two entries
are aliases in the frame of the given instruction.</p><p>While this idea seems elegant at first sight, Miguel's implementation does not merge frames
correctly when it comes to aliasing. Assume in frame 1, values (a, b, c) are aliases, while in
frame 2 (a, b) are aliases. When merging the second into the first, we have to make sure that
c is removed as an alias of (a, b).</p><p>It would be possible to implement correct alias set merging in Miguel's approach. However, frame
merging is the main hot spot of analysis. The computational complexity of implementing alias set
merging by traversing the values array and comparing references is too high. The concrete
alias set representation that is used in the current implementation (see class AliasingFrame)
makes alias set merging more efficient.</p><p>[1] https://github.com/scala-opt/scala/blob/opt/rebase/src/compiler/scala/tools/nsc/backend/bcode/NullnessPropagator.java</p><p>Complexity and scaling of analysis
----------------------------------</p><p>The time complexity of a data flow analysis depends on:</p><ul><li>The size of the method. The complexity factor is linear (assuming the number of locals and
    branching instructions remains constant). The main analysis loop runs through all
    instructions of a method once. Instructions are only re-enqueued if a control flow merge
    changes the frame at some instruction.</li><li>The branching instructions. When a second (third, ..) control flow edge arrives at an
    instruction, the existing frame at the instruction is merged with the one computed on the
    new branch. If the merge function changes the existing frame, the instruction is enqueued
    for another analysis. This results in a merge operation for the successors of the
    instruction.</li><li>The number of local variables. The hot spot of analysis is frame merging. The merge function
    iterates through the values in the frame (locals and stack values) and merges them.</li></ul><p>I measured the running time of an analysis for two examples:</p><ul><li>Keep the number of locals and branching instructions constant, increase the number of
    instructions. The running time grows linearly with the method size.</li><li>Increase the size and number of locals in a method. The method size and number of locals
    grow in the same pace. Here, the running time increase is polynomial. It looks like the
    complexity is be #instructions * #locals^2 (see below).</li></ul><p>I measured nullness analysis (which tracks aliases) and a SimpleValue analysis. Nullness runs
roughly 5x slower (because of alias tracking) at every problem size - this factor doesn't change.</p><p>The numbers below are for nullness. Note that the last column is constant, i.e., the running
time is proportional to #ins * #loc^2. Therefore we use this factor when limiting the maximal
method size for running an analysis.</p><p>  #insns    #locals    time (ms)       time / #ins * #loc<sup>2 * 10</sup>6
  1305      156        34              1.07
  2610      311        165             0.65
  3915      466        490             0.57
  5220      621        1200            0.59
  6525      776        2220            0.56
  7830      931        3830            0.56
  9135      1086       6570            0.60
  10440     1241       9700            0.60
  11745     1396       13800           0.60</p><p>As a second experiment, nullness analysis was run with varying #insns but constant #locals.
The last column shows linear complexity with respect to the method size (linearOffset = 2279):</p><p>  #insns     #locals     time (ms)    (time + linearOffset) / #insns
  5220       621         1090         0.645
  6224       621         1690         0.637
  7226       621         2280         0.630
  8228       621         2870         0.625
  9230       621         3530         0.629
  10232      621         4130         0.626
  11234      621         4770         0.627
  12236      621         5520         0.637
  13238      621         6170         0.638</p><p>When running a BasicValue analysis, the complexity observation is the same (time is proportional
to #ins * #loc^2).</p><p>Measuring analysis execution time
---------------------------------</p><p>See code below.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.opt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="opt" class="anchorToMember"></a><a id="opt:opt" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/opt/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="opt/index.html" title=""><span class="name">opt</span></a></span></li></ol></div><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="scala.tools.nsc.backend.jvm.BCodeBodyBuilder" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="BCodeBodyBuilderextendsBCodeSkelBuilder" class="anchorToMember"></a><a id="BCodeBodyBuilder:BCodeBodyBuilder" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BCodeBodyBuilder.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BCodeBodyBuilder.html" title=""><span class="name">BCodeBodyBuilder</span></a><span class="result"> extends <a href="BCodeSkelBuilder.html" name="scala.tools.nsc.backend.jvm.BCodeSkelBuilder" id="scala.tools.nsc.backend.jvm.BCodeSkelBuilder" class="extype">BCodeSkelBuilder</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BCodeHelpers" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="BCodeHelpersextendsBCodeIdiomatic" class="anchorToMember"></a><a id="BCodeHelpers:BCodeHelpers" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BCodeHelpers.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BCodeHelpers.html" title=""><span class="name">BCodeHelpers</span></a><span class="result"> extends <a href="BCodeIdiomatic.html" name="scala.tools.nsc.backend.jvm.BCodeIdiomatic" id="scala.tools.nsc.backend.jvm.BCodeIdiomatic" class="extype">BCodeIdiomatic</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BCodeIdiomatic" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="BCodeIdiomaticextendsAnyRef" class="anchorToMember"></a><a id="BCodeIdiomatic:BCodeIdiomatic" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BCodeIdiomatic.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BCodeIdiomatic.html" title=""><span class="name">BCodeIdiomatic</span></a><span class="result"> extends <a href="../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BCodeSkelBuilder" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="BCodeSkelBuilderextendsBCodeHelpers" class="anchorToMember"></a><a id="BCodeSkelBuilder:BCodeSkelBuilder" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BCodeSkelBuilder.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BCodeSkelBuilder.html" title=""><span class="name">BCodeSkelBuilder</span></a><span class="result"> extends <a href="BCodeHelpers.html" name="scala.tools.nsc.backend.jvm.BCodeHelpers" id="scala.tools.nsc.backend.jvm.BCodeHelpers" class="extype">BCodeHelpers</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BCodeSyncAndTry" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="BCodeSyncAndTryextendsBCodeBodyBuilder" class="anchorToMember"></a><a id="BCodeSyncAndTry:BCodeSyncAndTry" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BCodeSyncAndTry.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BCodeSyncAndTry.html" title=""><span class="name">BCodeSyncAndTry</span></a><span class="result"> extends <a href="BCodeBodyBuilder.html" name="scala.tools.nsc.backend.jvm.BCodeBodyBuilder" id="scala.tools.nsc.backend.jvm.BCodeBodyBuilder" class="extype">BCodeBodyBuilder</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BTypes" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="BTypesextendsAnyRef" class="anchorToMember"></a><a id="BTypes:BTypes" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BTypes.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BTypes.html" title="The BTypes component defines The BType class hierarchy."><span class="name">BTypes</span></a><span class="result"> extends <a href="../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt">The BTypes component defines The BType class hierarchy.</p><div class="fullcomment"><div class="comment cmt"><p>The BTypes component defines The BType class hierarchy. A BType stores all type information
that is required after building the ASM nodes. This includes optimizations, generation of
InnerClass attributes and generation of stack map frames.</p><p>The representation is immutable and independent of the compiler data structures, hence it can
be queried by concurrent threads.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BTypesFromClassfile" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="BTypesFromClassfileextendsAnyRef" class="anchorToMember"></a><a id="BTypesFromClassfile:BTypesFromClassfile" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BTypesFromClassfile.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BTypesFromClassfile.html" title=""><span class="name">BTypesFromClassfile</span></a><span class="result"> extends <a href="../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BTypesFromSymbols" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="BTypesFromSymbols[G&lt;:scala.tools.nsc.Global]extendsBTypes" class="anchorToMember"></a><a id="BTypesFromSymbols[G&lt;:Global]:BTypesFromSymbols[G]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BTypesFromSymbols.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BTypesFromSymbols.html" title="This class mainly contains the method classBTypeFromSymbol, which extracts the necessary information from a symbol and its type to create the corresponding ClassBType."><span class="name">BTypesFromSymbols</span></a><span class="tparams">[<span name="G">G &lt;: <a href="../../Global.html" name="scala.tools.nsc.Global" id="scala.tools.nsc.Global" class="extype">Global</a></span>]</span><span class="result"> extends <a href="BTypes.html" name="scala.tools.nsc.backend.jvm.BTypes" id="scala.tools.nsc.backend.jvm.BTypes" class="extype">BTypes</a></span></span><p class="shortcomment cmt">This class mainly contains the method classBTypeFromSymbol, which extracts the necessary
information from a symbol and its type to create the corresponding ClassBType.</p><div class="fullcomment"><div class="comment cmt"><p>This class mainly contains the method classBTypeFromSymbol, which extracts the necessary
information from a symbol and its type to create the corresponding ClassBType. It requires
access to the compiler (global parameter).
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BackendStats" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="BackendStatsextendsAnyRef" class="anchorToMember"></a><a id="BackendStats:BackendStats" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BackendStats.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="BackendStats.html" title=""><span class="name">BackendStats</span></a><span class="result"> extends <a href="../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.ClassNode1" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ClassNode1extendsClassNode" class="anchorToMember"></a><a id="ClassNode1:ClassNode1" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/ClassNode1.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="ClassNode1.html" title="A subclass of ClassNode to customize the representation of label nodes with LabelNode1."><span class="name">ClassNode1</span></a><span class="result"> extends <span name="scala.tools.asm.tree.ClassNode" class="extype">ClassNode</span></span></span><p class="shortcomment cmt">A subclass of <code><span name="ClassNode" class="extype">ClassNode</span></code> to customize the representation of
label nodes with <code><a href="LabelNode1.html" name="scala.tools.nsc.backend.jvm.LabelNode1" id="scala.tools.nsc.backend.jvm.LabelNode1" class="extype">LabelNode1</a></code>.</p></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.ClassfileWriters" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="ClassfileWritersextendsAnyRef" class="anchorToMember"></a><a id="ClassfileWriters:ClassfileWriters" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/ClassfileWriters.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="ClassfileWriters.html" title=""><span class="name">ClassfileWriters</span></a><span class="result"> extends <a href="../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.ClearableJConcurrentHashMap" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ClearableJConcurrentHashMap[K,V]extendsClearable" class="anchorToMember"></a><a id="ClearableJConcurrentHashMap[K,V]:ClearableJConcurrentHashMap[K,V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/ClearableJConcurrentHashMap.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="ClearableJConcurrentHashMap.html" title=""><span class="name">ClearableJConcurrentHashMap</span></a><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.12/scala/collection/mutable/Clearable.html#scala.collection.mutable.Clearable" name="scala.collection.mutable.Clearable" id="scala.collection.mutable.Clearable" class="extype">Clearable</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.CodeGen" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="CodeGen[G&lt;:scala.tools.nsc.Global]extendsPerRunInit" class="anchorToMember"></a><a id="CodeGen[G&lt;:Global]:CodeGen[G]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/CodeGen.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="CodeGen.html" title=""><span class="name">CodeGen</span></a><span class="tparams">[<span name="G">G &lt;: <a href="../../Global.html" name="scala.tools.nsc.Global" id="scala.tools.nsc.Global" class="extype">Global</a></span>]</span><span class="result"> extends <a href="PerRunInit.html" name="scala.tools.nsc.backend.jvm.PerRunInit" id="scala.tools.nsc.backend.jvm.PerRunInit" class="extype">PerRunInit</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.CompilationUnitInPostProcess" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="CompilationUnitInPostProcessextendsAnyRef" class="anchorToMember"></a><a id="CompilationUnitInPostProcess:CompilationUnitInPostProcess" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/CompilationUnitInPostProcess.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="CompilationUnitInPostProcess.html" title="State for a compilation unit being post-processed."><span class="name">CompilationUnitInPostProcess</span></a><span class="result"> extends <a href="../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt">State for a compilation unit being post-processed.</p><div class="fullcomment"><div class="comment cmt"><p>State for a compilation unit being post-processed.</p><ul><li>Holds the classes to post-process (released for GC when no longer used)</li><li>Keeps a reference to the future that runs the post-processor</li><li>Buffers messages reported during post-processing
</li></ul></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.CoreBTypes" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="CoreBTypesextendsPerRunInit" class="anchorToMember"></a><a id="CoreBTypes:CoreBTypes" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/CoreBTypes.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="CoreBTypes.html" title=""><span class="name">CoreBTypes</span></a><span class="result"> extends <a href="PerRunInit.html" name="scala.tools.nsc.backend.jvm.PerRunInit" id="scala.tools.nsc.backend.jvm.PerRunInit" class="extype">PerRunInit</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.CoreBTypesFromSymbols" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="CoreBTypesFromSymbols[G&lt;:scala.tools.nsc.Global]extendsCoreBTypes" class="anchorToMember"></a><a id="CoreBTypesFromSymbols[G&lt;:Global]:CoreBTypesFromSymbols[G]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/CoreBTypesFromSymbols.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="CoreBTypesFromSymbols.html" title=""><span class="name">CoreBTypesFromSymbols</span></a><span class="tparams">[<span name="G">G &lt;: <a href="../../Global.html" name="scala.tools.nsc.Global" id="scala.tools.nsc.Global" class="extype">Global</a></span>]</span><span class="result"> extends <a href="CoreBTypes.html" name="scala.tools.nsc.backend.jvm.CoreBTypes" id="scala.tools.nsc.backend.jvm.CoreBTypes" class="extype">CoreBTypes</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.GenBCode" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="GenBCodeextendsSubComponent" class="anchorToMember"></a><a id="GenBCode:GenBCode" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/GenBCode.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="GenBCode.html" title="Some notes about the backend's state and its initialization and release."><span class="name">GenBCode</span></a><span class="result"> extends <a href="../../SubComponent.html" name="scala.tools.nsc.SubComponent" id="scala.tools.nsc.SubComponent" class="extype">SubComponent</a></span></span><p class="shortcomment cmt">Some notes about the backend's state and its initialization and release.</p><div class="fullcomment"><div class="comment cmt"><p>Some notes about the backend's state and its initialization and release.</p><p>State that is used in a single run is allocated through <code>recordPerRunCache</code>, for example
<code>ByteCodeRepository.compilingClasses</code> or <code>CallGraph.callsites</code>. This state is cleared at the end
of each run.</p><p>Some state needs to be re-initialized per run, for example <code>CoreBTypes</code> (computed from Symbols /
Types) or the <code>GeneratedClassHandler</code> (depends on the compiler settings). This state is
(re-) initialized in the <code>GenBCode.initialize</code> method. There two categories:</p><ol class="decimal"><li>State that is stored in a <code>var</code> field and (re-) assigned in the <code>initialize</code> method, for
     example the <code>GeneratedClassHandler</code>
  2. State that uses the <code>PerRunInit</code> / <code>bTypes.perRunLazy</code> / <code>LazyVar</code> infrastructure, for
     example the types in <code>CoreBTypes</code></li></ol><p>The reason to use the <code>LazyVar</code> infrastructure is to prevent eagerly computing all the state
even if it's never used in a run. It can also be used to work around initialization ordering
issues, just like ordinary lazy vals. For state that is known to be accessed, a <code>var</code> field is
just fine.</p><p>Typical <code>LazyVar</code> use: <code>lazy val state: LazyVar[T] = perRunLazy(component)(initializer)</code></p><ul><li>The <code>initializer</code> expression is executed lazily</li><li>When the initializer actually runs, it synchronizes on the
    <code>PostProcessorFrontendAccess.frontendLock</code></li><li>The <code>component.initialize</code> method causes the <code>LazyVar</code> to be re-initialized on the next <code>get</code></li><li>The <code>state</code> is itself a <code>lazy val</code> to make sure the <code>component.initialize</code> method only
    clears those <code>LazyVar</code>s that were ever accessed</li></ul><p>TODO: convert some uses of <code>LazyVar</code> to ordinary <code>var</code>.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.GeneratedClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="GeneratedClassextendsProductwithSerializable" class="anchorToMember"></a><a id="GeneratedClass:GeneratedClass" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/GeneratedClass.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="GeneratedClass.html" title="The result of code generation."><span class="name">GeneratedClass</span></a><span class="params">(<span name="classNode">classNode: <span name="scala.tools.asm.tree.ClassNode" class="extype">ClassNode</span></span>, <span name="sourceClassName">sourceClassName: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="position">position: <a href="https://www.scala-lang.org/api/2.13.12/scala-reflect/scala/reflect/internal/util/Position.html#scala.reflect.internal.util.Position" name="scala.reflect.internal.util.Position" id="scala.reflect.internal.util.Position" class="extype">Position</a></span>, <span name="isArtifact">isArtifact: <a href="https://www.scala-lang.org/api/2.13.12/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.12/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <a href="../../../../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span><p class="shortcomment cmt">The result of code generation.</p><div class="fullcomment"><div class="comment cmt"><p>The result of code generation. <a href="GeneratedClass.html#isArtifact:Boolean" name="scala.tools.nsc.backend.jvm.GeneratedClass#isArtifact" id="scala.tools.nsc.backend.jvm.GeneratedClass#isArtifact" class="extmbr">isArtifact</a> is <code>true</code> for mirror and bean-info classes.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.GeneratedCompilationUnit" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="GeneratedCompilationUnitextendsProductwithSerializable" class="anchorToMember"></a><a id="GeneratedCompilationUnit:GeneratedCompilationUnit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/GeneratedCompilationUnit.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="GeneratedCompilationUnit.html" title=""><span class="name">GeneratedCompilationUnit</span></a><span class="params">(<span name="sourceFile">sourceFile: <a href="https://www.scala-lang.org/api/2.13.12/scala-reflect/scala/reflect/io/AbstractFile.html#scala.reflect.io.AbstractFile" name="scala.reflect.io.AbstractFile" id="scala.reflect.io.AbstractFile" class="extype">AbstractFile</a></span>, <span name="classes">classes: <a href="../../../../index.html#List[+A]=List[A]" name="scala.List" id="scala.List" class="extmbr">List</a>[<a href="GeneratedClass.html" name="scala.tools.nsc.backend.jvm.GeneratedClass" id="scala.tools.nsc.backend.jvm.GeneratedClass" class="extype">GeneratedClass</a>]</span>)</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.12/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <a href="../../../../index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.LabelNode1" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="LabelNode1extendsLabelNode" class="anchorToMember"></a><a id="LabelNode1:LabelNode1" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/LabelNode1.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="LabelNode1.html" title="A subclass of LabelNode to add user-definable flags."><span class="name">LabelNode1</span></a><span class="result"> extends <span name="scala.tools.asm.tree.LabelNode" class="extype">LabelNode</span></span></span><p class="shortcomment cmt">A subclass of <code><span name="LabelNode" class="extype">LabelNode</span></code> to add user-definable flags.</p></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.MethodNode1" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="MethodNode1extendsMethodNode" class="anchorToMember"></a><a id="MethodNode1:MethodNode1" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/MethodNode1.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="MethodNode1.html" title="A subclass of MethodNode to customize the representation of label nodes with LabelNode1."><span class="name">MethodNode1</span></a><span class="result"> extends <span name="scala.tools.asm.tree.MethodNode" class="extype">MethodNode</span></span></span><p class="shortcomment cmt">A subclass of <code><span name="MethodNode" class="extype">MethodNode</span></code> to customize the representation of
label nodes with <code><a href="LabelNode1.html" name="scala.tools.nsc.backend.jvm.LabelNode1" id="scala.tools.nsc.backend.jvm.LabelNode1" class="extype">LabelNode1</a></code>.</p></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.PerRunInit" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="PerRunInitextendsAnyRef" class="anchorToMember"></a><a id="PerRunInit:PerRunInit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/PerRunInit.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="PerRunInit.html" title="Utility for backend components that have state that needs to be re-initialized at every compiler run, for example state that depends on compiler settings of frontend types (Symbols, Types)."><span class="name">PerRunInit</span></a><span class="result"> extends <a href="../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt">Utility for backend components that have state that needs to be re-initialized at every compiler
run, for example state that depends on compiler settings of frontend types (Symbols, Types).</p><div class="fullcomment"><div class="comment cmt"><p>Utility for backend components that have state that needs to be re-initialized at every compiler
run, for example state that depends on compiler settings of frontend types (Symbols, Types).</p><p>The trait provides an <code>initialize</code> method that runs all initializers added through <code>perRunLazy</code>.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.PostProcessor" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="PostProcessorextendsPerRunInit" class="anchorToMember"></a><a id="PostProcessor:PostProcessor" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/PostProcessor.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="PostProcessor.html" title="Implements late stages of the backend that don't depend on a Global instance, i.e., optimizations, post-processing and classfile serialization and writing."><span class="name">PostProcessor</span></a><span class="result"> extends <a href="PerRunInit.html" name="scala.tools.nsc.backend.jvm.PerRunInit" id="scala.tools.nsc.backend.jvm.PerRunInit" class="extype">PerRunInit</a></span></span><p class="shortcomment cmt">Implements late stages of the backend that don't depend on a Global instance, i.e.,
optimizations, post-processing and classfile serialization and writing.</p></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.PostProcessorFrontendAccess" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="PostProcessorFrontendAccessextendsAnyRef" class="anchorToMember"></a><a id="PostProcessorFrontendAccess:PostProcessorFrontendAccess" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/PostProcessorFrontendAccess.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="PostProcessorFrontendAccess.html" title="Functionality needed in the post-processor whose implementation depends on the compiler frontend."><span class="name">PostProcessorFrontendAccess</span></a><span class="result"> extends <a href="../../../../index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><p class="shortcomment cmt">Functionality needed in the post-processor whose implementation depends on the compiler
frontend.</p><div class="fullcomment"><div class="comment cmt"><p>Functionality needed in the post-processor whose implementation depends on the compiler
frontend. All methods are synchronized.
</p></div></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.tools.nsc.backend.jvm.AsmUtils" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="AsmUtils" class="anchorToMember"></a><a id="AsmUtils:AsmUtils" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/AsmUtils$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="AsmUtils$.html" title=""><span class="name">AsmUtils</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BCodeHelpers" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="BCodeHelpers" class="anchorToMember"></a><a id="BCodeHelpers:BCodeHelpers" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BCodeHelpers$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="BCodeHelpers$.html" title=""><span class="name">BCodeHelpers</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BTypes" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="BTypes" class="anchorToMember"></a><a id="BTypes:BTypes" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BTypes$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="BTypes$.html" title=""><span class="name">BTypes</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.BackendReporting" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="BackendReporting" class="anchorToMember"></a><a id="BackendReporting:BackendReporting" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/BackendReporting$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="BackendReporting$.html" title="Utilities for error reporting."><span class="name">BackendReporting</span></a></span><p class="shortcomment cmt">Utilities for error reporting.</p><div class="fullcomment"><div class="comment cmt"><p>Utilities for error reporting.</p><p>Defines some utility methods to make error reporting with Either easier.
</p></div></div></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.GenBCode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="GenBCode" class="anchorToMember"></a><a id="GenBCode:GenBCode" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/GenBCode$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="GenBCode$.html" title=""><span class="name">GenBCode</span></a></span></li><li class="indented0 " name="scala.tools.nsc.backend.jvm.PostProcessorFrontendAccess" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PostProcessorFrontendAccess" class="anchorToMember"></a><a id="PostProcessorFrontendAccess:PostProcessorFrontendAccess" class="anchorToMember"></a> <span class="permalink"><a href="../../../../../scala/tools/nsc/backend/jvm/PostProcessorFrontendAccess$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="PostProcessorFrontendAccess$.html" title=""><span class="name">PostProcessorFrontendAccess</span></a></span></li></ol></div></div><div id="inheritedMembers"></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer">Scala programming documentation. Copyright (c) 2002-2023 <a href="https://www.epfl.ch" target="_top">EPFL</a> and <a href="https://www.lightbend.com" target="_top">Lightbend</a>.</div></body></div></div></div></body></html>
